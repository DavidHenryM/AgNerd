
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Graze` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Graze
 * 
 */
export type GrazeModel = runtime.Types.Result.DefaultSelection<Prisma.$GrazePayload>

export type AggregateGraze = {
  _count: GrazeCountAggregateOutputType | null
  _avg: GrazeAvgAggregateOutputType | null
  _sum: GrazeSumAggregateOutputType | null
  _min: GrazeMinAggregateOutputType | null
  _max: GrazeMaxAggregateOutputType | null
}

export type GrazeAvgAggregateOutputType = {
  dseDaysPerHectare: number | null
}

export type GrazeSumAggregateOutputType = {
  dseDaysPerHectare: number | null
}

export type GrazeMinAggregateOutputType = {
  id: string | null
  startDatetime: Date | null
  endDateTime: Date | null
  paddockId: string | null
  dseDaysPerHectare: number | null
}

export type GrazeMaxAggregateOutputType = {
  id: string | null
  startDatetime: Date | null
  endDateTime: Date | null
  paddockId: string | null
  dseDaysPerHectare: number | null
}

export type GrazeCountAggregateOutputType = {
  id: number
  startDatetime: number
  endDateTime: number
  paddockId: number
  dseDaysPerHectare: number
  _all: number
}


export type GrazeAvgAggregateInputType = {
  dseDaysPerHectare?: true
}

export type GrazeSumAggregateInputType = {
  dseDaysPerHectare?: true
}

export type GrazeMinAggregateInputType = {
  id?: true
  startDatetime?: true
  endDateTime?: true
  paddockId?: true
  dseDaysPerHectare?: true
}

export type GrazeMaxAggregateInputType = {
  id?: true
  startDatetime?: true
  endDateTime?: true
  paddockId?: true
  dseDaysPerHectare?: true
}

export type GrazeCountAggregateInputType = {
  id?: true
  startDatetime?: true
  endDateTime?: true
  paddockId?: true
  dseDaysPerHectare?: true
  _all?: true
}

export type GrazeAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Graze to aggregate.
   */
  where?: Prisma.GrazeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Grazes to fetch.
   */
  orderBy?: Prisma.GrazeOrderByWithRelationInput | Prisma.GrazeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.GrazeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Grazes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Grazes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Grazes
  **/
  _count?: true | GrazeCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: GrazeAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: GrazeSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: GrazeMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: GrazeMaxAggregateInputType
}

export type GetGrazeAggregateType<T extends GrazeAggregateArgs> = {
      [P in keyof T & keyof AggregateGraze]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateGraze[P]>
    : Prisma.GetScalarType<T[P], AggregateGraze[P]>
}




export type GrazeGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GrazeWhereInput
  orderBy?: Prisma.GrazeOrderByWithAggregationInput | Prisma.GrazeOrderByWithAggregationInput[]
  by: Prisma.GrazeScalarFieldEnum[] | Prisma.GrazeScalarFieldEnum
  having?: Prisma.GrazeScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: GrazeCountAggregateInputType | true
  _avg?: GrazeAvgAggregateInputType
  _sum?: GrazeSumAggregateInputType
  _min?: GrazeMinAggregateInputType
  _max?: GrazeMaxAggregateInputType
}

export type GrazeGroupByOutputType = {
  id: string
  startDatetime: Date
  endDateTime: Date | null
  paddockId: string
  dseDaysPerHectare: number | null
  _count: GrazeCountAggregateOutputType | null
  _avg: GrazeAvgAggregateOutputType | null
  _sum: GrazeSumAggregateOutputType | null
  _min: GrazeMinAggregateOutputType | null
  _max: GrazeMaxAggregateOutputType | null
}

type GetGrazeGroupByPayload<T extends GrazeGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<GrazeGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof GrazeGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], GrazeGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], GrazeGroupByOutputType[P]>
      }
    >
  >



export type GrazeWhereInput = {
  AND?: Prisma.GrazeWhereInput | Prisma.GrazeWhereInput[]
  OR?: Prisma.GrazeWhereInput[]
  NOT?: Prisma.GrazeWhereInput | Prisma.GrazeWhereInput[]
  id?: Prisma.StringFilter<"Graze"> | string
  startDatetime?: Prisma.DateTimeFilter<"Graze"> | Date | string
  endDateTime?: Prisma.DateTimeNullableFilter<"Graze"> | Date | string | null
  paddockId?: Prisma.StringFilter<"Graze"> | string
  dseDaysPerHectare?: Prisma.FloatNullableFilter<"Graze"> | number | null
  paddock?: Prisma.XOR<Prisma.PaddockScalarRelationFilter, Prisma.PaddockWhereInput>
  mobs?: Prisma.GrazeMobListRelationFilter
}

export type GrazeOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  startDatetime?: Prisma.SortOrder
  endDateTime?: Prisma.SortOrderInput | Prisma.SortOrder
  paddockId?: Prisma.SortOrder
  dseDaysPerHectare?: Prisma.SortOrderInput | Prisma.SortOrder
  paddock?: Prisma.PaddockOrderByWithRelationInput
  mobs?: Prisma.GrazeMobOrderByRelationAggregateInput
}

export type GrazeWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  paddockId?: string
  AND?: Prisma.GrazeWhereInput | Prisma.GrazeWhereInput[]
  OR?: Prisma.GrazeWhereInput[]
  NOT?: Prisma.GrazeWhereInput | Prisma.GrazeWhereInput[]
  startDatetime?: Prisma.DateTimeFilter<"Graze"> | Date | string
  endDateTime?: Prisma.DateTimeNullableFilter<"Graze"> | Date | string | null
  dseDaysPerHectare?: Prisma.FloatNullableFilter<"Graze"> | number | null
  paddock?: Prisma.XOR<Prisma.PaddockScalarRelationFilter, Prisma.PaddockWhereInput>
  mobs?: Prisma.GrazeMobListRelationFilter
}, "id" | "paddockId">

export type GrazeOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  startDatetime?: Prisma.SortOrder
  endDateTime?: Prisma.SortOrderInput | Prisma.SortOrder
  paddockId?: Prisma.SortOrder
  dseDaysPerHectare?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.GrazeCountOrderByAggregateInput
  _avg?: Prisma.GrazeAvgOrderByAggregateInput
  _max?: Prisma.GrazeMaxOrderByAggregateInput
  _min?: Prisma.GrazeMinOrderByAggregateInput
  _sum?: Prisma.GrazeSumOrderByAggregateInput
}

export type GrazeScalarWhereWithAggregatesInput = {
  AND?: Prisma.GrazeScalarWhereWithAggregatesInput | Prisma.GrazeScalarWhereWithAggregatesInput[]
  OR?: Prisma.GrazeScalarWhereWithAggregatesInput[]
  NOT?: Prisma.GrazeScalarWhereWithAggregatesInput | Prisma.GrazeScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Graze"> | string
  startDatetime?: Prisma.DateTimeWithAggregatesFilter<"Graze"> | Date | string
  endDateTime?: Prisma.DateTimeNullableWithAggregatesFilter<"Graze"> | Date | string | null
  paddockId?: Prisma.StringWithAggregatesFilter<"Graze"> | string
  dseDaysPerHectare?: Prisma.FloatNullableWithAggregatesFilter<"Graze"> | number | null
}

export type GrazeCreateInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  dseDaysPerHectare?: number | null
  paddock: Prisma.PaddockCreateNestedOneWithoutGrazeInput
  mobs?: Prisma.GrazeMobCreateNestedManyWithoutGrazeInput
}

export type GrazeUncheckedCreateInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  paddockId: string
  dseDaysPerHectare?: number | null
  mobs?: Prisma.GrazeMobUncheckedCreateNestedManyWithoutGrazeInput
}

export type GrazeUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  paddock?: Prisma.PaddockUpdateOneRequiredWithoutGrazeNestedInput
  mobs?: Prisma.GrazeMobUpdateManyWithoutGrazeNestedInput
}

export type GrazeUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  paddockId?: Prisma.StringFieldUpdateOperationsInput | string
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  mobs?: Prisma.GrazeMobUncheckedUpdateManyWithoutGrazeNestedInput
}

export type GrazeCreateManyInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  paddockId: string
  dseDaysPerHectare?: number | null
}

export type GrazeUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type GrazeUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  paddockId?: Prisma.StringFieldUpdateOperationsInput | string
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type GrazeCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  startDatetime?: Prisma.SortOrder
  endDateTime?: Prisma.SortOrder
  paddockId?: Prisma.SortOrder
  dseDaysPerHectare?: Prisma.SortOrder
}

export type GrazeAvgOrderByAggregateInput = {
  dseDaysPerHectare?: Prisma.SortOrder
}

export type GrazeMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  startDatetime?: Prisma.SortOrder
  endDateTime?: Prisma.SortOrder
  paddockId?: Prisma.SortOrder
  dseDaysPerHectare?: Prisma.SortOrder
}

export type GrazeMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  startDatetime?: Prisma.SortOrder
  endDateTime?: Prisma.SortOrder
  paddockId?: Prisma.SortOrder
  dseDaysPerHectare?: Prisma.SortOrder
}

export type GrazeSumOrderByAggregateInput = {
  dseDaysPerHectare?: Prisma.SortOrder
}

export type GrazeScalarRelationFilter = {
  is?: Prisma.GrazeWhereInput
  isNot?: Prisma.GrazeWhereInput
}

export type GrazeListRelationFilter = {
  every?: Prisma.GrazeWhereInput
  some?: Prisma.GrazeWhereInput
  none?: Prisma.GrazeWhereInput
}

export type GrazeOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type GrazeCreateNestedOneWithoutMobsInput = {
  create?: Prisma.XOR<Prisma.GrazeCreateWithoutMobsInput, Prisma.GrazeUncheckedCreateWithoutMobsInput>
  connectOrCreate?: Prisma.GrazeCreateOrConnectWithoutMobsInput
  connect?: Prisma.GrazeWhereUniqueInput
}

export type GrazeUpdateOneRequiredWithoutMobsNestedInput = {
  create?: Prisma.XOR<Prisma.GrazeCreateWithoutMobsInput, Prisma.GrazeUncheckedCreateWithoutMobsInput>
  connectOrCreate?: Prisma.GrazeCreateOrConnectWithoutMobsInput
  upsert?: Prisma.GrazeUpsertWithoutMobsInput
  connect?: Prisma.GrazeWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.GrazeUpdateToOneWithWhereWithoutMobsInput, Prisma.GrazeUpdateWithoutMobsInput>, Prisma.GrazeUncheckedUpdateWithoutMobsInput>
}

export type GrazeCreateNestedManyWithoutPaddockInput = {
  create?: Prisma.XOR<Prisma.GrazeCreateWithoutPaddockInput, Prisma.GrazeUncheckedCreateWithoutPaddockInput> | Prisma.GrazeCreateWithoutPaddockInput[] | Prisma.GrazeUncheckedCreateWithoutPaddockInput[]
  connectOrCreate?: Prisma.GrazeCreateOrConnectWithoutPaddockInput | Prisma.GrazeCreateOrConnectWithoutPaddockInput[]
  createMany?: Prisma.GrazeCreateManyPaddockInputEnvelope
  connect?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
}

export type GrazeUncheckedCreateNestedManyWithoutPaddockInput = {
  create?: Prisma.XOR<Prisma.GrazeCreateWithoutPaddockInput, Prisma.GrazeUncheckedCreateWithoutPaddockInput> | Prisma.GrazeCreateWithoutPaddockInput[] | Prisma.GrazeUncheckedCreateWithoutPaddockInput[]
  connectOrCreate?: Prisma.GrazeCreateOrConnectWithoutPaddockInput | Prisma.GrazeCreateOrConnectWithoutPaddockInput[]
  createMany?: Prisma.GrazeCreateManyPaddockInputEnvelope
  connect?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
}

export type GrazeUpdateManyWithoutPaddockNestedInput = {
  create?: Prisma.XOR<Prisma.GrazeCreateWithoutPaddockInput, Prisma.GrazeUncheckedCreateWithoutPaddockInput> | Prisma.GrazeCreateWithoutPaddockInput[] | Prisma.GrazeUncheckedCreateWithoutPaddockInput[]
  connectOrCreate?: Prisma.GrazeCreateOrConnectWithoutPaddockInput | Prisma.GrazeCreateOrConnectWithoutPaddockInput[]
  upsert?: Prisma.GrazeUpsertWithWhereUniqueWithoutPaddockInput | Prisma.GrazeUpsertWithWhereUniqueWithoutPaddockInput[]
  createMany?: Prisma.GrazeCreateManyPaddockInputEnvelope
  set?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  disconnect?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  delete?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  connect?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  update?: Prisma.GrazeUpdateWithWhereUniqueWithoutPaddockInput | Prisma.GrazeUpdateWithWhereUniqueWithoutPaddockInput[]
  updateMany?: Prisma.GrazeUpdateManyWithWhereWithoutPaddockInput | Prisma.GrazeUpdateManyWithWhereWithoutPaddockInput[]
  deleteMany?: Prisma.GrazeScalarWhereInput | Prisma.GrazeScalarWhereInput[]
}

export type GrazeUncheckedUpdateManyWithoutPaddockNestedInput = {
  create?: Prisma.XOR<Prisma.GrazeCreateWithoutPaddockInput, Prisma.GrazeUncheckedCreateWithoutPaddockInput> | Prisma.GrazeCreateWithoutPaddockInput[] | Prisma.GrazeUncheckedCreateWithoutPaddockInput[]
  connectOrCreate?: Prisma.GrazeCreateOrConnectWithoutPaddockInput | Prisma.GrazeCreateOrConnectWithoutPaddockInput[]
  upsert?: Prisma.GrazeUpsertWithWhereUniqueWithoutPaddockInput | Prisma.GrazeUpsertWithWhereUniqueWithoutPaddockInput[]
  createMany?: Prisma.GrazeCreateManyPaddockInputEnvelope
  set?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  disconnect?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  delete?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  connect?: Prisma.GrazeWhereUniqueInput | Prisma.GrazeWhereUniqueInput[]
  update?: Prisma.GrazeUpdateWithWhereUniqueWithoutPaddockInput | Prisma.GrazeUpdateWithWhereUniqueWithoutPaddockInput[]
  updateMany?: Prisma.GrazeUpdateManyWithWhereWithoutPaddockInput | Prisma.GrazeUpdateManyWithWhereWithoutPaddockInput[]
  deleteMany?: Prisma.GrazeScalarWhereInput | Prisma.GrazeScalarWhereInput[]
}

export type GrazeCreateWithoutMobsInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  dseDaysPerHectare?: number | null
  paddock: Prisma.PaddockCreateNestedOneWithoutGrazeInput
}

export type GrazeUncheckedCreateWithoutMobsInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  paddockId: string
  dseDaysPerHectare?: number | null
}

export type GrazeCreateOrConnectWithoutMobsInput = {
  where: Prisma.GrazeWhereUniqueInput
  create: Prisma.XOR<Prisma.GrazeCreateWithoutMobsInput, Prisma.GrazeUncheckedCreateWithoutMobsInput>
}

export type GrazeUpsertWithoutMobsInput = {
  update: Prisma.XOR<Prisma.GrazeUpdateWithoutMobsInput, Prisma.GrazeUncheckedUpdateWithoutMobsInput>
  create: Prisma.XOR<Prisma.GrazeCreateWithoutMobsInput, Prisma.GrazeUncheckedCreateWithoutMobsInput>
  where?: Prisma.GrazeWhereInput
}

export type GrazeUpdateToOneWithWhereWithoutMobsInput = {
  where?: Prisma.GrazeWhereInput
  data: Prisma.XOR<Prisma.GrazeUpdateWithoutMobsInput, Prisma.GrazeUncheckedUpdateWithoutMobsInput>
}

export type GrazeUpdateWithoutMobsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  paddock?: Prisma.PaddockUpdateOneRequiredWithoutGrazeNestedInput
}

export type GrazeUncheckedUpdateWithoutMobsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  paddockId?: Prisma.StringFieldUpdateOperationsInput | string
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type GrazeCreateWithoutPaddockInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  dseDaysPerHectare?: number | null
  mobs?: Prisma.GrazeMobCreateNestedManyWithoutGrazeInput
}

export type GrazeUncheckedCreateWithoutPaddockInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  dseDaysPerHectare?: number | null
  mobs?: Prisma.GrazeMobUncheckedCreateNestedManyWithoutGrazeInput
}

export type GrazeCreateOrConnectWithoutPaddockInput = {
  where: Prisma.GrazeWhereUniqueInput
  create: Prisma.XOR<Prisma.GrazeCreateWithoutPaddockInput, Prisma.GrazeUncheckedCreateWithoutPaddockInput>
}

export type GrazeCreateManyPaddockInputEnvelope = {
  data: Prisma.GrazeCreateManyPaddockInput | Prisma.GrazeCreateManyPaddockInput[]
  skipDuplicates?: boolean
}

export type GrazeUpsertWithWhereUniqueWithoutPaddockInput = {
  where: Prisma.GrazeWhereUniqueInput
  update: Prisma.XOR<Prisma.GrazeUpdateWithoutPaddockInput, Prisma.GrazeUncheckedUpdateWithoutPaddockInput>
  create: Prisma.XOR<Prisma.GrazeCreateWithoutPaddockInput, Prisma.GrazeUncheckedCreateWithoutPaddockInput>
}

export type GrazeUpdateWithWhereUniqueWithoutPaddockInput = {
  where: Prisma.GrazeWhereUniqueInput
  data: Prisma.XOR<Prisma.GrazeUpdateWithoutPaddockInput, Prisma.GrazeUncheckedUpdateWithoutPaddockInput>
}

export type GrazeUpdateManyWithWhereWithoutPaddockInput = {
  where: Prisma.GrazeScalarWhereInput
  data: Prisma.XOR<Prisma.GrazeUpdateManyMutationInput, Prisma.GrazeUncheckedUpdateManyWithoutPaddockInput>
}

export type GrazeScalarWhereInput = {
  AND?: Prisma.GrazeScalarWhereInput | Prisma.GrazeScalarWhereInput[]
  OR?: Prisma.GrazeScalarWhereInput[]
  NOT?: Prisma.GrazeScalarWhereInput | Prisma.GrazeScalarWhereInput[]
  id?: Prisma.StringFilter<"Graze"> | string
  startDatetime?: Prisma.DateTimeFilter<"Graze"> | Date | string
  endDateTime?: Prisma.DateTimeNullableFilter<"Graze"> | Date | string | null
  paddockId?: Prisma.StringFilter<"Graze"> | string
  dseDaysPerHectare?: Prisma.FloatNullableFilter<"Graze"> | number | null
}

export type GrazeCreateManyPaddockInput = {
  id?: string
  startDatetime: Date | string
  endDateTime?: Date | string | null
  dseDaysPerHectare?: number | null
}

export type GrazeUpdateWithoutPaddockInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  mobs?: Prisma.GrazeMobUpdateManyWithoutGrazeNestedInput
}

export type GrazeUncheckedUpdateWithoutPaddockInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  mobs?: Prisma.GrazeMobUncheckedUpdateManyWithoutGrazeNestedInput
}

export type GrazeUncheckedUpdateManyWithoutPaddockInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startDatetime?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDateTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  dseDaysPerHectare?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}


/**
 * Count Type GrazeCountOutputType
 */

export type GrazeCountOutputType = {
  mobs: number
}

export type GrazeCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  mobs?: boolean | GrazeCountOutputTypeCountMobsArgs
}

/**
 * GrazeCountOutputType without action
 */
export type GrazeCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GrazeCountOutputType
   */
  select?: Prisma.GrazeCountOutputTypeSelect<ExtArgs> | null
}

/**
 * GrazeCountOutputType without action
 */
export type GrazeCountOutputTypeCountMobsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GrazeMobWhereInput
}


export type GrazeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  startDatetime?: boolean
  endDateTime?: boolean
  paddockId?: boolean
  dseDaysPerHectare?: boolean
  paddock?: boolean | Prisma.PaddockDefaultArgs<ExtArgs>
  mobs?: boolean | Prisma.Graze$mobsArgs<ExtArgs>
  _count?: boolean | Prisma.GrazeCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["graze"]>

export type GrazeSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  startDatetime?: boolean
  endDateTime?: boolean
  paddockId?: boolean
  dseDaysPerHectare?: boolean
  paddock?: boolean | Prisma.PaddockDefaultArgs<ExtArgs>
}, ExtArgs["result"]["graze"]>

export type GrazeSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  startDatetime?: boolean
  endDateTime?: boolean
  paddockId?: boolean
  dseDaysPerHectare?: boolean
  paddock?: boolean | Prisma.PaddockDefaultArgs<ExtArgs>
}, ExtArgs["result"]["graze"]>

export type GrazeSelectScalar = {
  id?: boolean
  startDatetime?: boolean
  endDateTime?: boolean
  paddockId?: boolean
  dseDaysPerHectare?: boolean
}

export type GrazeOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "startDatetime" | "endDateTime" | "paddockId" | "dseDaysPerHectare", ExtArgs["result"]["graze"]>
export type GrazeInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  paddock?: boolean | Prisma.PaddockDefaultArgs<ExtArgs>
  mobs?: boolean | Prisma.Graze$mobsArgs<ExtArgs>
  _count?: boolean | Prisma.GrazeCountOutputTypeDefaultArgs<ExtArgs>
}
export type GrazeIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  paddock?: boolean | Prisma.PaddockDefaultArgs<ExtArgs>
}
export type GrazeIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  paddock?: boolean | Prisma.PaddockDefaultArgs<ExtArgs>
}

export type $GrazePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Graze"
  objects: {
    paddock: Prisma.$PaddockPayload<ExtArgs>
    mobs: Prisma.$GrazeMobPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    startDatetime: Date
    endDateTime: Date | null
    paddockId: string
    dseDaysPerHectare: number | null
  }, ExtArgs["result"]["graze"]>
  composites: {}
}

export type GrazeGetPayload<S extends boolean | null | undefined | GrazeDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$GrazePayload, S>

export type GrazeCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<GrazeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
    select?: GrazeCountAggregateInputType | true
  }

export interface GrazeDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Graze'], meta: { name: 'Graze' } }
  /**
   * Find zero or one Graze that matches the filter.
   * @param {GrazeFindUniqueArgs} args - Arguments to find a Graze
   * @example
   * // Get one Graze
   * const graze = await prisma.graze.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends GrazeFindUniqueArgs>(args: Prisma.SelectSubset<T, GrazeFindUniqueArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Graze that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {GrazeFindUniqueOrThrowArgs} args - Arguments to find a Graze
   * @example
   * // Get one Graze
   * const graze = await prisma.graze.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends GrazeFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, GrazeFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Graze that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GrazeFindFirstArgs} args - Arguments to find a Graze
   * @example
   * // Get one Graze
   * const graze = await prisma.graze.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends GrazeFindFirstArgs>(args?: Prisma.SelectSubset<T, GrazeFindFirstArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Graze that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GrazeFindFirstOrThrowArgs} args - Arguments to find a Graze
   * @example
   * // Get one Graze
   * const graze = await prisma.graze.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends GrazeFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, GrazeFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Grazes that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GrazeFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Grazes
   * const grazes = await prisma.graze.findMany()
   * 
   * // Get first 10 Grazes
   * const grazes = await prisma.graze.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const grazeWithIdOnly = await prisma.graze.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends GrazeFindManyArgs>(args?: Prisma.SelectSubset<T, GrazeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Graze.
   * @param {GrazeCreateArgs} args - Arguments to create a Graze.
   * @example
   * // Create one Graze
   * const Graze = await prisma.graze.create({
   *   data: {
   *     // ... data to create a Graze
   *   }
   * })
   * 
   */
  create<T extends GrazeCreateArgs>(args: Prisma.SelectSubset<T, GrazeCreateArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Grazes.
   * @param {GrazeCreateManyArgs} args - Arguments to create many Grazes.
   * @example
   * // Create many Grazes
   * const graze = await prisma.graze.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends GrazeCreateManyArgs>(args?: Prisma.SelectSubset<T, GrazeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Grazes and returns the data saved in the database.
   * @param {GrazeCreateManyAndReturnArgs} args - Arguments to create many Grazes.
   * @example
   * // Create many Grazes
   * const graze = await prisma.graze.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Grazes and only return the `id`
   * const grazeWithIdOnly = await prisma.graze.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends GrazeCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, GrazeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Graze.
   * @param {GrazeDeleteArgs} args - Arguments to delete one Graze.
   * @example
   * // Delete one Graze
   * const Graze = await prisma.graze.delete({
   *   where: {
   *     // ... filter to delete one Graze
   *   }
   * })
   * 
   */
  delete<T extends GrazeDeleteArgs>(args: Prisma.SelectSubset<T, GrazeDeleteArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Graze.
   * @param {GrazeUpdateArgs} args - Arguments to update one Graze.
   * @example
   * // Update one Graze
   * const graze = await prisma.graze.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends GrazeUpdateArgs>(args: Prisma.SelectSubset<T, GrazeUpdateArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Grazes.
   * @param {GrazeDeleteManyArgs} args - Arguments to filter Grazes to delete.
   * @example
   * // Delete a few Grazes
   * const { count } = await prisma.graze.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends GrazeDeleteManyArgs>(args?: Prisma.SelectSubset<T, GrazeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Grazes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GrazeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Grazes
   * const graze = await prisma.graze.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends GrazeUpdateManyArgs>(args: Prisma.SelectSubset<T, GrazeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Grazes and returns the data updated in the database.
   * @param {GrazeUpdateManyAndReturnArgs} args - Arguments to update many Grazes.
   * @example
   * // Update many Grazes
   * const graze = await prisma.graze.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Grazes and only return the `id`
   * const grazeWithIdOnly = await prisma.graze.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends GrazeUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, GrazeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Graze.
   * @param {GrazeUpsertArgs} args - Arguments to update or create a Graze.
   * @example
   * // Update or create a Graze
   * const graze = await prisma.graze.upsert({
   *   create: {
   *     // ... data to create a Graze
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Graze we want to update
   *   }
   * })
   */
  upsert<T extends GrazeUpsertArgs>(args: Prisma.SelectSubset<T, GrazeUpsertArgs<ExtArgs>>): Prisma.Prisma__GrazeClient<runtime.Types.Result.GetResult<Prisma.$GrazePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Grazes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GrazeCountArgs} args - Arguments to filter Grazes to count.
   * @example
   * // Count the number of Grazes
   * const count = await prisma.graze.count({
   *   where: {
   *     // ... the filter for the Grazes we want to count
   *   }
   * })
  **/
  count<T extends GrazeCountArgs>(
    args?: Prisma.Subset<T, GrazeCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], GrazeCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Graze.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GrazeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends GrazeAggregateArgs>(args: Prisma.Subset<T, GrazeAggregateArgs>): Prisma.PrismaPromise<GetGrazeAggregateType<T>>

  /**
   * Group by Graze.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GrazeGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends GrazeGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: GrazeGroupByArgs['orderBy'] }
      : { orderBy?: GrazeGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, GrazeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrazeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Graze model
 */
readonly fields: GrazeFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Graze.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__GrazeClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  paddock<T extends Prisma.PaddockDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PaddockDefaultArgs<ExtArgs>>): Prisma.Prisma__PaddockClient<runtime.Types.Result.GetResult<Prisma.$PaddockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  mobs<T extends Prisma.Graze$mobsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Graze$mobsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GrazeMobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Graze model
 */
export interface GrazeFieldRefs {
  readonly id: Prisma.FieldRef<"Graze", 'String'>
  readonly startDatetime: Prisma.FieldRef<"Graze", 'DateTime'>
  readonly endDateTime: Prisma.FieldRef<"Graze", 'DateTime'>
  readonly paddockId: Prisma.FieldRef<"Graze", 'String'>
  readonly dseDaysPerHectare: Prisma.FieldRef<"Graze", 'Float'>
}
    

// Custom InputTypes
/**
 * Graze findUnique
 */
export type GrazeFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * Filter, which Graze to fetch.
   */
  where: Prisma.GrazeWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze findUniqueOrThrow
 */
export type GrazeFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * Filter, which Graze to fetch.
   */
  where: Prisma.GrazeWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze findFirst
 */
export type GrazeFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * Filter, which Graze to fetch.
   */
  where?: Prisma.GrazeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Grazes to fetch.
   */
  orderBy?: Prisma.GrazeOrderByWithRelationInput | Prisma.GrazeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Grazes.
   */
  cursor?: Prisma.GrazeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Grazes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Grazes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Grazes.
   */
  distinct?: Prisma.GrazeScalarFieldEnum | Prisma.GrazeScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze findFirstOrThrow
 */
export type GrazeFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * Filter, which Graze to fetch.
   */
  where?: Prisma.GrazeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Grazes to fetch.
   */
  orderBy?: Prisma.GrazeOrderByWithRelationInput | Prisma.GrazeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Grazes.
   */
  cursor?: Prisma.GrazeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Grazes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Grazes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Grazes.
   */
  distinct?: Prisma.GrazeScalarFieldEnum | Prisma.GrazeScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze findMany
 */
export type GrazeFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * Filter, which Grazes to fetch.
   */
  where?: Prisma.GrazeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Grazes to fetch.
   */
  orderBy?: Prisma.GrazeOrderByWithRelationInput | Prisma.GrazeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Grazes.
   */
  cursor?: Prisma.GrazeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Grazes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Grazes.
   */
  skip?: number
  distinct?: Prisma.GrazeScalarFieldEnum | Prisma.GrazeScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze create
 */
export type GrazeCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * The data needed to create a Graze.
   */
  data: Prisma.XOR<Prisma.GrazeCreateInput, Prisma.GrazeUncheckedCreateInput>
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze createMany
 */
export type GrazeCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Grazes.
   */
  data: Prisma.GrazeCreateManyInput | Prisma.GrazeCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Graze createManyAndReturn
 */
export type GrazeCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * The data used to create many Grazes.
   */
  data: Prisma.GrazeCreateManyInput | Prisma.GrazeCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Graze update
 */
export type GrazeUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * The data needed to update a Graze.
   */
  data: Prisma.XOR<Prisma.GrazeUpdateInput, Prisma.GrazeUncheckedUpdateInput>
  /**
   * Choose, which Graze to update.
   */
  where: Prisma.GrazeWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze updateMany
 */
export type GrazeUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Grazes.
   */
  data: Prisma.XOR<Prisma.GrazeUpdateManyMutationInput, Prisma.GrazeUncheckedUpdateManyInput>
  /**
   * Filter which Grazes to update
   */
  where?: Prisma.GrazeWhereInput
  /**
   * Limit how many Grazes to update.
   */
  limit?: number
}

/**
 * Graze updateManyAndReturn
 */
export type GrazeUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * The data used to update Grazes.
   */
  data: Prisma.XOR<Prisma.GrazeUpdateManyMutationInput, Prisma.GrazeUncheckedUpdateManyInput>
  /**
   * Filter which Grazes to update
   */
  where?: Prisma.GrazeWhereInput
  /**
   * Limit how many Grazes to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Graze upsert
 */
export type GrazeUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * The filter to search for the Graze to update in case it exists.
   */
  where: Prisma.GrazeWhereUniqueInput
  /**
   * In case the Graze found by the `where` argument doesn't exist, create a new Graze with this data.
   */
  create: Prisma.XOR<Prisma.GrazeCreateInput, Prisma.GrazeUncheckedCreateInput>
  /**
   * In case the Graze was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.GrazeUpdateInput, Prisma.GrazeUncheckedUpdateInput>
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze delete
 */
export type GrazeDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
  /**
   * Filter which Graze to delete.
   */
  where: Prisma.GrazeWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * Graze deleteMany
 */
export type GrazeDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Grazes to delete
   */
  where?: Prisma.GrazeWhereInput
  /**
   * Limit how many Grazes to delete.
   */
  limit?: number
}

/**
 * Graze.mobs
 */
export type Graze$mobsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GrazeMob
   */
  select?: Prisma.GrazeMobSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GrazeMob
   */
  omit?: Prisma.GrazeMobOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeMobInclude<ExtArgs> | null
  where?: Prisma.GrazeMobWhereInput
  orderBy?: Prisma.GrazeMobOrderByWithRelationInput | Prisma.GrazeMobOrderByWithRelationInput[]
  cursor?: Prisma.GrazeMobWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.GrazeMobScalarFieldEnum | Prisma.GrazeMobScalarFieldEnum[]
}

/**
 * Graze without action
 */
export type GrazeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Graze
   */
  select?: Prisma.GrazeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Graze
   */
  omit?: Prisma.GrazeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GrazeInclude<ExtArgs> | null
}
