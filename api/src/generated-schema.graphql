# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateBreed {
  _count: BreedCountAggregate
  _max: BreedMaxAggregate
  _min: BreedMinAggregate
}

type AggregateGeoPoint {
  _avg: GeoPointAvgAggregate
  _count: GeoPointCountAggregate
  _max: GeoPointMaxAggregate
  _min: GeoPointMinAggregate
  _sum: GeoPointSumAggregate
}

type AggregateGraze {
  _count: GrazeCountAggregate
  _max: GrazeMaxAggregate
  _min: GrazeMinAggregate
}

type AggregateLivestockUnit {
  _count: LivestockUnitCountAggregate
  _max: LivestockUnitMaxAggregate
  _min: LivestockUnitMinAggregate
}

type AggregateMob {
  _count: MobCountAggregate
  _max: MobMaxAggregate
  _min: MobMinAggregate
}

type AggregatePaddock {
  _count: PaddockCountAggregate
  _max: PaddockMaxAggregate
  _min: PaddockMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type AggregateWeightRecord {
  _avg: WeightRecordAvgAggregate
  _count: WeightRecordCountAggregate
  _max: WeightRecordMaxAggregate
  _min: WeightRecordMinAggregate
  _sum: WeightRecordSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Breed {
  class: StockClass!
  id: String!
  memberId: String
  members: LivestockUnit
  name: String!
}

type BreedCountAggregate {
  _all: Int!
  class: Int!
  id: Int!
  memberId: Int!
  name: Int!
}

input BreedCountOrderByAggregateInput {
  class: SortOrder
  id: SortOrder
  memberId: SortOrder
  name: SortOrder
}

input BreedCreateInput {
  class: StockClass!
  id: String
  members: LivestockUnitCreateNestedOneWithoutBreedInput
  name: String!
}

input BreedCreateManyInput {
  class: StockClass!
  id: String
  memberId: String
  name: String!
}

input BreedCreateNestedOneWithoutMembersInput {
  connect: BreedWhereUniqueInput
  connectOrCreate: BreedCreateOrConnectWithoutMembersInput
  create: BreedCreateWithoutMembersInput
}

input BreedCreateOrConnectWithoutMembersInput {
  create: BreedCreateWithoutMembersInput!
  where: BreedWhereUniqueInput!
}

input BreedCreateWithoutMembersInput {
  class: StockClass!
  id: String
  name: String!
}

type BreedGroupBy {
  _count: BreedCountAggregate
  _max: BreedMaxAggregate
  _min: BreedMinAggregate
  class: StockClass!
  id: String!
  memberId: String
  name: String!
}

type BreedMaxAggregate {
  class: StockClass
  id: String
  memberId: String
  name: String
}

input BreedMaxOrderByAggregateInput {
  class: SortOrder
  id: SortOrder
  memberId: SortOrder
  name: SortOrder
}

type BreedMinAggregate {
  class: StockClass
  id: String
  memberId: String
  name: String
}

input BreedMinOrderByAggregateInput {
  class: SortOrder
  id: SortOrder
  memberId: SortOrder
  name: SortOrder
}

input BreedOrderByWithAggregationInput {
  _count: BreedCountOrderByAggregateInput
  _max: BreedMaxOrderByAggregateInput
  _min: BreedMinOrderByAggregateInput
  class: SortOrder
  id: SortOrder
  memberId: SortOrder
  name: SortOrder
}

input BreedOrderByWithRelationInput {
  class: SortOrder
  id: SortOrder
  memberId: SortOrder
  members: LivestockUnitOrderByWithRelationInput
  name: SortOrder
}

input BreedRelationFilter {
  is: BreedWhereInput
  isNot: BreedWhereInput
}

enum BreedScalarFieldEnum {
  class
  id
  memberId
  name
}

input BreedScalarWhereWithAggregatesInput {
  AND: [BreedScalarWhereWithAggregatesInput!]
  NOT: [BreedScalarWhereWithAggregatesInput!]
  OR: [BreedScalarWhereWithAggregatesInput!]
  class: EnumStockClassWithAggregatesFilter
  id: StringWithAggregatesFilter
  memberId: StringNullableWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input BreedUpdateInput {
  class: EnumStockClassFieldUpdateOperationsInput
  members: LivestockUnitUpdateOneWithoutBreedNestedInput
  name: StringFieldUpdateOperationsInput
}

input BreedUpdateManyMutationInput {
  class: EnumStockClassFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input BreedUpdateOneWithoutMembersNestedInput {
  connect: BreedWhereUniqueInput
  connectOrCreate: BreedCreateOrConnectWithoutMembersInput
  create: BreedCreateWithoutMembersInput
  delete: Boolean
  disconnect: Boolean
  update: BreedUpdateWithoutMembersInput
  upsert: BreedUpsertWithoutMembersInput
}

input BreedUpdateWithoutMembersInput {
  class: EnumStockClassFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input BreedUpsertWithoutMembersInput {
  create: BreedCreateWithoutMembersInput!
  update: BreedUpdateWithoutMembersInput!
}

input BreedWhereInput {
  AND: [BreedWhereInput!]
  NOT: [BreedWhereInput!]
  OR: [BreedWhereInput!]
  class: EnumStockClassFilter
  id: StringFilter
  memberId: StringNullableFilter
  members: LivestockUnitRelationFilter
  name: StringFilter
}

input BreedWhereUniqueInput {
  id: String
  memberId: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  isSet: Boolean
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  isSet: Boolean
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumSexFieldUpdateOperationsInput {
  set: Sex
}

input EnumSexFilter {
  equals: Sex
  in: [Sex!]
  not: NestedEnumSexFilter
  notIn: [Sex!]
}

input EnumSexWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumSexFilter
  _min: NestedEnumSexFilter
  equals: Sex
  in: [Sex!]
  not: NestedEnumSexWithAggregatesFilter
  notIn: [Sex!]
}

input EnumStockClassFieldUpdateOperationsInput {
  set: StockClass
}

input EnumStockClassFilter {
  equals: StockClass
  in: [StockClass!]
  not: NestedEnumStockClassFilter
  notIn: [StockClass!]
}

input EnumStockClassWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumStockClassFilter
  _min: NestedEnumStockClassFilter
  equals: StockClass
  in: [StockClass!]
  not: NestedEnumStockClassWithAggregatesFilter
  notIn: [StockClass!]
}

input EnumWeighMethodFieldUpdateOperationsInput {
  set: WeighMethod
}

input EnumWeighMethodFilter {
  equals: WeighMethod
  in: [WeighMethod!]
  not: NestedEnumWeighMethodFilter
  notIn: [WeighMethod!]
}

input EnumWeighMethodWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumWeighMethodFilter
  _min: NestedEnumWeighMethodFilter
  equals: WeighMethod
  in: [WeighMethod!]
  not: NestedEnumWeighMethodWithAggregatesFilter
  notIn: [WeighMethod!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

type GeoPoint {
  id: String!
  latitude: Float!
  longitude: Float!
  paddock: Paddock!
  paddockId: String!
}

type GeoPointAvgAggregate {
  latitude: Float
  longitude: Float
}

input GeoPointAvgOrderByAggregateInput {
  latitude: SortOrder
  longitude: SortOrder
}

type GeoPointCountAggregate {
  _all: Int!
  id: Int!
  latitude: Int!
  longitude: Int!
  paddockId: Int!
}

input GeoPointCountOrderByAggregateInput {
  id: SortOrder
  latitude: SortOrder
  longitude: SortOrder
  paddockId: SortOrder
}

input GeoPointCreateInput {
  id: String
  latitude: Float!
  longitude: Float!
  paddock: PaddockCreateNestedOneWithoutPolygonInput!
}

input GeoPointCreateManyInput {
  id: String
  latitude: Float!
  longitude: Float!
  paddockId: String!
}

input GeoPointCreateManyPaddockInput {
  id: String
  latitude: Float!
  longitude: Float!
}

input GeoPointCreateManyPaddockInputEnvelope {
  data: [GeoPointCreateManyPaddockInput!]!
}

input GeoPointCreateNestedManyWithoutPaddockInput {
  connect: [GeoPointWhereUniqueInput!]
  connectOrCreate: [GeoPointCreateOrConnectWithoutPaddockInput!]
  create: [GeoPointCreateWithoutPaddockInput!]
  createMany: GeoPointCreateManyPaddockInputEnvelope
}

input GeoPointCreateOrConnectWithoutPaddockInput {
  create: GeoPointCreateWithoutPaddockInput!
  where: GeoPointWhereUniqueInput!
}

input GeoPointCreateWithoutPaddockInput {
  id: String
  latitude: Float!
  longitude: Float!
}

type GeoPointGroupBy {
  _avg: GeoPointAvgAggregate
  _count: GeoPointCountAggregate
  _max: GeoPointMaxAggregate
  _min: GeoPointMinAggregate
  _sum: GeoPointSumAggregate
  id: String!
  latitude: Float!
  longitude: Float!
  paddockId: String!
}

input GeoPointListRelationFilter {
  every: GeoPointWhereInput
  none: GeoPointWhereInput
  some: GeoPointWhereInput
}

type GeoPointMaxAggregate {
  id: String
  latitude: Float
  longitude: Float
  paddockId: String
}

input GeoPointMaxOrderByAggregateInput {
  id: SortOrder
  latitude: SortOrder
  longitude: SortOrder
  paddockId: SortOrder
}

type GeoPointMinAggregate {
  id: String
  latitude: Float
  longitude: Float
  paddockId: String
}

input GeoPointMinOrderByAggregateInput {
  id: SortOrder
  latitude: SortOrder
  longitude: SortOrder
  paddockId: SortOrder
}

input GeoPointOrderByRelationAggregateInput {
  _count: SortOrder
}

input GeoPointOrderByWithAggregationInput {
  _avg: GeoPointAvgOrderByAggregateInput
  _count: GeoPointCountOrderByAggregateInput
  _max: GeoPointMaxOrderByAggregateInput
  _min: GeoPointMinOrderByAggregateInput
  _sum: GeoPointSumOrderByAggregateInput
  id: SortOrder
  latitude: SortOrder
  longitude: SortOrder
  paddockId: SortOrder
}

input GeoPointOrderByWithRelationInput {
  id: SortOrder
  latitude: SortOrder
  longitude: SortOrder
  paddock: PaddockOrderByWithRelationInput
  paddockId: SortOrder
}

enum GeoPointScalarFieldEnum {
  id
  latitude
  longitude
  paddockId
}

input GeoPointScalarWhereInput {
  AND: [GeoPointScalarWhereInput!]
  NOT: [GeoPointScalarWhereInput!]
  OR: [GeoPointScalarWhereInput!]
  id: StringFilter
  latitude: FloatFilter
  longitude: FloatFilter
  paddockId: StringFilter
}

input GeoPointScalarWhereWithAggregatesInput {
  AND: [GeoPointScalarWhereWithAggregatesInput!]
  NOT: [GeoPointScalarWhereWithAggregatesInput!]
  OR: [GeoPointScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  latitude: FloatWithAggregatesFilter
  longitude: FloatWithAggregatesFilter
  paddockId: StringWithAggregatesFilter
}

type GeoPointSumAggregate {
  latitude: Float
  longitude: Float
}

input GeoPointSumOrderByAggregateInput {
  latitude: SortOrder
  longitude: SortOrder
}

input GeoPointUpdateInput {
  latitude: FloatFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
  paddock: PaddockUpdateOneRequiredWithoutPolygonNestedInput
}

input GeoPointUpdateManyMutationInput {
  latitude: FloatFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
}

input GeoPointUpdateManyWithWhereWithoutPaddockInput {
  data: GeoPointUpdateManyMutationInput!
  where: GeoPointScalarWhereInput!
}

input GeoPointUpdateManyWithoutPaddockNestedInput {
  connect: [GeoPointWhereUniqueInput!]
  connectOrCreate: [GeoPointCreateOrConnectWithoutPaddockInput!]
  create: [GeoPointCreateWithoutPaddockInput!]
  createMany: GeoPointCreateManyPaddockInputEnvelope
  delete: [GeoPointWhereUniqueInput!]
  deleteMany: [GeoPointScalarWhereInput!]
  disconnect: [GeoPointWhereUniqueInput!]
  set: [GeoPointWhereUniqueInput!]
  update: [GeoPointUpdateWithWhereUniqueWithoutPaddockInput!]
  updateMany: [GeoPointUpdateManyWithWhereWithoutPaddockInput!]
  upsert: [GeoPointUpsertWithWhereUniqueWithoutPaddockInput!]
}

input GeoPointUpdateWithWhereUniqueWithoutPaddockInput {
  data: GeoPointUpdateWithoutPaddockInput!
  where: GeoPointWhereUniqueInput!
}

input GeoPointUpdateWithoutPaddockInput {
  latitude: FloatFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
}

input GeoPointUpsertWithWhereUniqueWithoutPaddockInput {
  create: GeoPointCreateWithoutPaddockInput!
  update: GeoPointUpdateWithoutPaddockInput!
  where: GeoPointWhereUniqueInput!
}

input GeoPointWhereInput {
  AND: [GeoPointWhereInput!]
  NOT: [GeoPointWhereInput!]
  OR: [GeoPointWhereInput!]
  id: StringFilter
  latitude: FloatFilter
  longitude: FloatFilter
  paddock: PaddockRelationFilter
  paddockId: StringFilter
}

input GeoPointWhereUniqueInput {
  id: String
  paddockId: String
}

type Graze {
  _count: GrazeCount
  endDateTime: DateTime
  id: String!
  mob(cursor: MobWhereUniqueInput, distinct: [MobScalarFieldEnum!], orderBy: [MobOrderByWithRelationInput!], skip: Int, take: Int, where: MobWhereInput): [Mob!]!
  mobIds: [String!]!
  paddock: Paddock!
  paddockId: String!
  startDatetime: DateTime!
}

type GrazeCount {
  mob: Int!
}

type GrazeCountAggregate {
  _all: Int!
  endDateTime: Int!
  id: Int!
  mobIds: Int!
  paddockId: Int!
  startDatetime: Int!
}

input GrazeCountOrderByAggregateInput {
  endDateTime: SortOrder
  id: SortOrder
  mobIds: SortOrder
  paddockId: SortOrder
  startDatetime: SortOrder
}

input GrazeCreateInput {
  endDateTime: DateTime
  id: String
  mob: MobCreateNestedManyWithoutGrazeInput
  mobIds: GrazeCreatemobIdsInput
  paddock: PaddockCreateNestedOneWithoutGrazeInput!
  startDatetime: DateTime!
}

input GrazeCreateManyInput {
  endDateTime: DateTime
  id: String
  mobIds: GrazeCreatemobIdsInput
  paddockId: String!
  startDatetime: DateTime!
}

input GrazeCreateManyPaddockInput {
  endDateTime: DateTime
  id: String
  mobIds: GrazeCreatemobIdsInput
  startDatetime: DateTime!
}

input GrazeCreateManyPaddockInputEnvelope {
  data: [GrazeCreateManyPaddockInput!]!
}

input GrazeCreateNestedManyWithoutMobInput {
  connect: [GrazeWhereUniqueInput!]
  connectOrCreate: [GrazeCreateOrConnectWithoutMobInput!]
  create: [GrazeCreateWithoutMobInput!]
}

input GrazeCreateNestedManyWithoutPaddockInput {
  connect: [GrazeWhereUniqueInput!]
  connectOrCreate: [GrazeCreateOrConnectWithoutPaddockInput!]
  create: [GrazeCreateWithoutPaddockInput!]
  createMany: GrazeCreateManyPaddockInputEnvelope
}

input GrazeCreateOrConnectWithoutMobInput {
  create: GrazeCreateWithoutMobInput!
  where: GrazeWhereUniqueInput!
}

input GrazeCreateOrConnectWithoutPaddockInput {
  create: GrazeCreateWithoutPaddockInput!
  where: GrazeWhereUniqueInput!
}

input GrazeCreateWithoutMobInput {
  endDateTime: DateTime
  id: String
  mobIds: GrazeCreatemobIdsInput
  paddock: PaddockCreateNestedOneWithoutGrazeInput!
  startDatetime: DateTime!
}

input GrazeCreateWithoutPaddockInput {
  endDateTime: DateTime
  id: String
  mob: MobCreateNestedManyWithoutGrazeInput
  mobIds: GrazeCreatemobIdsInput
  startDatetime: DateTime!
}

input GrazeCreatemobIdsInput {
  set: [String!]!
}

type GrazeGroupBy {
  _count: GrazeCountAggregate
  _max: GrazeMaxAggregate
  _min: GrazeMinAggregate
  endDateTime: DateTime
  id: String!
  mobIds: [String!]
  paddockId: String!
  startDatetime: DateTime!
}

input GrazeListRelationFilter {
  every: GrazeWhereInput
  none: GrazeWhereInput
  some: GrazeWhereInput
}

type GrazeMaxAggregate {
  endDateTime: DateTime
  id: String
  paddockId: String
  startDatetime: DateTime
}

input GrazeMaxOrderByAggregateInput {
  endDateTime: SortOrder
  id: SortOrder
  paddockId: SortOrder
  startDatetime: SortOrder
}

type GrazeMinAggregate {
  endDateTime: DateTime
  id: String
  paddockId: String
  startDatetime: DateTime
}

input GrazeMinOrderByAggregateInput {
  endDateTime: SortOrder
  id: SortOrder
  paddockId: SortOrder
  startDatetime: SortOrder
}

input GrazeOrderByRelationAggregateInput {
  _count: SortOrder
}

input GrazeOrderByWithAggregationInput {
  _count: GrazeCountOrderByAggregateInput
  _max: GrazeMaxOrderByAggregateInput
  _min: GrazeMinOrderByAggregateInput
  endDateTime: SortOrder
  id: SortOrder
  mobIds: SortOrder
  paddockId: SortOrder
  startDatetime: SortOrder
}

input GrazeOrderByWithRelationInput {
  endDateTime: SortOrder
  id: SortOrder
  mob: MobOrderByRelationAggregateInput
  mobIds: SortOrder
  paddock: PaddockOrderByWithRelationInput
  paddockId: SortOrder
  startDatetime: SortOrder
}

enum GrazeScalarFieldEnum {
  endDateTime
  id
  mobIds
  paddockId
  startDatetime
}

input GrazeScalarWhereInput {
  AND: [GrazeScalarWhereInput!]
  NOT: [GrazeScalarWhereInput!]
  OR: [GrazeScalarWhereInput!]
  endDateTime: DateTimeNullableFilter
  id: StringFilter
  mobIds: StringNullableListFilter
  paddockId: StringFilter
  startDatetime: DateTimeFilter
}

input GrazeScalarWhereWithAggregatesInput {
  AND: [GrazeScalarWhereWithAggregatesInput!]
  NOT: [GrazeScalarWhereWithAggregatesInput!]
  OR: [GrazeScalarWhereWithAggregatesInput!]
  endDateTime: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  mobIds: StringNullableListFilter
  paddockId: StringWithAggregatesFilter
  startDatetime: DateTimeWithAggregatesFilter
}

input GrazeUpdateInput {
  endDateTime: NullableDateTimeFieldUpdateOperationsInput
  mob: MobUpdateManyWithoutGrazeNestedInput
  mobIds: GrazeUpdatemobIdsInput
  paddock: PaddockUpdateOneRequiredWithoutGrazeNestedInput
  startDatetime: DateTimeFieldUpdateOperationsInput
}

input GrazeUpdateManyMutationInput {
  endDateTime: NullableDateTimeFieldUpdateOperationsInput
  mobIds: GrazeUpdatemobIdsInput
  startDatetime: DateTimeFieldUpdateOperationsInput
}

input GrazeUpdateManyWithWhereWithoutMobInput {
  data: GrazeUpdateManyMutationInput!
  where: GrazeScalarWhereInput!
}

input GrazeUpdateManyWithWhereWithoutPaddockInput {
  data: GrazeUpdateManyMutationInput!
  where: GrazeScalarWhereInput!
}

input GrazeUpdateManyWithoutMobNestedInput {
  connect: [GrazeWhereUniqueInput!]
  connectOrCreate: [GrazeCreateOrConnectWithoutMobInput!]
  create: [GrazeCreateWithoutMobInput!]
  delete: [GrazeWhereUniqueInput!]
  deleteMany: [GrazeScalarWhereInput!]
  disconnect: [GrazeWhereUniqueInput!]
  set: [GrazeWhereUniqueInput!]
  update: [GrazeUpdateWithWhereUniqueWithoutMobInput!]
  updateMany: [GrazeUpdateManyWithWhereWithoutMobInput!]
  upsert: [GrazeUpsertWithWhereUniqueWithoutMobInput!]
}

input GrazeUpdateManyWithoutPaddockNestedInput {
  connect: [GrazeWhereUniqueInput!]
  connectOrCreate: [GrazeCreateOrConnectWithoutPaddockInput!]
  create: [GrazeCreateWithoutPaddockInput!]
  createMany: GrazeCreateManyPaddockInputEnvelope
  delete: [GrazeWhereUniqueInput!]
  deleteMany: [GrazeScalarWhereInput!]
  disconnect: [GrazeWhereUniqueInput!]
  set: [GrazeWhereUniqueInput!]
  update: [GrazeUpdateWithWhereUniqueWithoutPaddockInput!]
  updateMany: [GrazeUpdateManyWithWhereWithoutPaddockInput!]
  upsert: [GrazeUpsertWithWhereUniqueWithoutPaddockInput!]
}

input GrazeUpdateWithWhereUniqueWithoutMobInput {
  data: GrazeUpdateWithoutMobInput!
  where: GrazeWhereUniqueInput!
}

input GrazeUpdateWithWhereUniqueWithoutPaddockInput {
  data: GrazeUpdateWithoutPaddockInput!
  where: GrazeWhereUniqueInput!
}

input GrazeUpdateWithoutMobInput {
  endDateTime: NullableDateTimeFieldUpdateOperationsInput
  mobIds: GrazeUpdatemobIdsInput
  paddock: PaddockUpdateOneRequiredWithoutGrazeNestedInput
  startDatetime: DateTimeFieldUpdateOperationsInput
}

input GrazeUpdateWithoutPaddockInput {
  endDateTime: NullableDateTimeFieldUpdateOperationsInput
  mob: MobUpdateManyWithoutGrazeNestedInput
  mobIds: GrazeUpdatemobIdsInput
  startDatetime: DateTimeFieldUpdateOperationsInput
}

input GrazeUpdatemobIdsInput {
  push: [String!]
  set: [String!]
}

input GrazeUpsertWithWhereUniqueWithoutMobInput {
  create: GrazeCreateWithoutMobInput!
  update: GrazeUpdateWithoutMobInput!
  where: GrazeWhereUniqueInput!
}

input GrazeUpsertWithWhereUniqueWithoutPaddockInput {
  create: GrazeCreateWithoutPaddockInput!
  update: GrazeUpdateWithoutPaddockInput!
  where: GrazeWhereUniqueInput!
}

input GrazeWhereInput {
  AND: [GrazeWhereInput!]
  NOT: [GrazeWhereInput!]
  OR: [GrazeWhereInput!]
  endDateTime: DateTimeNullableFilter
  id: StringFilter
  mob: MobListRelationFilter
  mobIds: StringNullableListFilter
  paddock: PaddockRelationFilter
  paddockId: StringFilter
  startDatetime: DateTimeFilter
}

input GrazeWhereUniqueInput {
  id: String
  paddockId: String
}

type LivestockUnit {
  _count: LivestockUnitCount
  birthdate: DateTime!
  breed: Breed
  comment: String
  dam: LivestockUnit
  desexed: Boolean!
  id: String!
  livestockUnitId: String!
  mob: Mob!
  name: String
  nlisid: String
  parentId: String
  sex: Sex!
  sire: LivestockUnit
  weights(cursor: WeightRecordWhereUniqueInput, distinct: [WeightRecordScalarFieldEnum!], orderBy: [WeightRecordOrderByWithRelationInput!], skip: Int, take: Int, where: WeightRecordWhereInput): [WeightRecord!]!
}

type LivestockUnitCount {
  weights: Int!
}

type LivestockUnitCountAggregate {
  _all: Int!
  birthdate: Int!
  comment: Int!
  desexed: Int!
  id: Int!
  livestockUnitId: Int!
  name: Int!
  nlisid: Int!
  parentId: Int!
  sex: Int!
}

input LivestockUnitCountOrderByAggregateInput {
  birthdate: SortOrder
  comment: SortOrder
  desexed: SortOrder
  id: SortOrder
  livestockUnitId: SortOrder
  name: SortOrder
  nlisid: SortOrder
  parentId: SortOrder
  sex: SortOrder
}

input LivestockUnitCreateInput {
  birthdate: DateTime!
  breed: BreedCreateNestedOneWithoutMembersInput
  comment: String
  dam: LivestockUnitCreateNestedOneWithoutSireInput
  desexed: Boolean!
  id: String
  mob: MobCreateNestedOneWithoutMembersInput!
  name: String
  nlisid: String
  sex: Sex!
  sire: LivestockUnitCreateNestedOneWithoutDamInput
  weights: WeightRecordCreateNestedManyWithoutLivestockUnitInput
}

input LivestockUnitCreateManyInput {
  birthdate: DateTime!
  comment: String
  desexed: Boolean!
  id: String
  livestockUnitId: String!
  name: String
  nlisid: String
  parentId: String
  sex: Sex!
}

input LivestockUnitCreateManyMobInput {
  birthdate: DateTime!
  comment: String
  desexed: Boolean!
  id: String
  name: String
  nlisid: String
  parentId: String
  sex: Sex!
}

input LivestockUnitCreateManyMobInputEnvelope {
  data: [LivestockUnitCreateManyMobInput!]!
}

input LivestockUnitCreateNestedManyWithoutMobInput {
  connect: [LivestockUnitWhereUniqueInput!]
  connectOrCreate: [LivestockUnitCreateOrConnectWithoutMobInput!]
  create: [LivestockUnitCreateWithoutMobInput!]
  createMany: LivestockUnitCreateManyMobInputEnvelope
}

input LivestockUnitCreateNestedOneWithoutBreedInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutBreedInput
  create: LivestockUnitCreateWithoutBreedInput
}

input LivestockUnitCreateNestedOneWithoutDamInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutDamInput
  create: LivestockUnitCreateWithoutDamInput
}

input LivestockUnitCreateNestedOneWithoutSireInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutSireInput
  create: LivestockUnitCreateWithoutSireInput
}

input LivestockUnitCreateNestedOneWithoutWeightsInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutWeightsInput
  create: LivestockUnitCreateWithoutWeightsInput
}

input LivestockUnitCreateOrConnectWithoutBreedInput {
  create: LivestockUnitCreateWithoutBreedInput!
  where: LivestockUnitWhereUniqueInput!
}

input LivestockUnitCreateOrConnectWithoutDamInput {
  create: LivestockUnitCreateWithoutDamInput!
  where: LivestockUnitWhereUniqueInput!
}

input LivestockUnitCreateOrConnectWithoutMobInput {
  create: LivestockUnitCreateWithoutMobInput!
  where: LivestockUnitWhereUniqueInput!
}

input LivestockUnitCreateOrConnectWithoutSireInput {
  create: LivestockUnitCreateWithoutSireInput!
  where: LivestockUnitWhereUniqueInput!
}

input LivestockUnitCreateOrConnectWithoutWeightsInput {
  create: LivestockUnitCreateWithoutWeightsInput!
  where: LivestockUnitWhereUniqueInput!
}

input LivestockUnitCreateWithoutBreedInput {
  birthdate: DateTime!
  comment: String
  dam: LivestockUnitCreateNestedOneWithoutSireInput
  desexed: Boolean!
  id: String
  mob: MobCreateNestedOneWithoutMembersInput!
  name: String
  nlisid: String
  sex: Sex!
  sire: LivestockUnitCreateNestedOneWithoutDamInput
  weights: WeightRecordCreateNestedManyWithoutLivestockUnitInput
}

input LivestockUnitCreateWithoutDamInput {
  birthdate: DateTime!
  breed: BreedCreateNestedOneWithoutMembersInput
  comment: String
  desexed: Boolean!
  id: String
  mob: MobCreateNestedOneWithoutMembersInput!
  name: String
  nlisid: String
  sex: Sex!
  sire: LivestockUnitCreateNestedOneWithoutDamInput
  weights: WeightRecordCreateNestedManyWithoutLivestockUnitInput
}

input LivestockUnitCreateWithoutMobInput {
  birthdate: DateTime!
  breed: BreedCreateNestedOneWithoutMembersInput
  comment: String
  dam: LivestockUnitCreateNestedOneWithoutSireInput
  desexed: Boolean!
  id: String
  name: String
  nlisid: String
  sex: Sex!
  sire: LivestockUnitCreateNestedOneWithoutDamInput
  weights: WeightRecordCreateNestedManyWithoutLivestockUnitInput
}

input LivestockUnitCreateWithoutSireInput {
  birthdate: DateTime!
  breed: BreedCreateNestedOneWithoutMembersInput
  comment: String
  dam: LivestockUnitCreateNestedOneWithoutSireInput
  desexed: Boolean!
  id: String
  mob: MobCreateNestedOneWithoutMembersInput!
  name: String
  nlisid: String
  sex: Sex!
  weights: WeightRecordCreateNestedManyWithoutLivestockUnitInput
}

input LivestockUnitCreateWithoutWeightsInput {
  birthdate: DateTime!
  breed: BreedCreateNestedOneWithoutMembersInput
  comment: String
  dam: LivestockUnitCreateNestedOneWithoutSireInput
  desexed: Boolean!
  id: String
  mob: MobCreateNestedOneWithoutMembersInput!
  name: String
  nlisid: String
  sex: Sex!
  sire: LivestockUnitCreateNestedOneWithoutDamInput
}

type LivestockUnitGroupBy {
  _count: LivestockUnitCountAggregate
  _max: LivestockUnitMaxAggregate
  _min: LivestockUnitMinAggregate
  birthdate: DateTime!
  comment: String
  desexed: Boolean!
  id: String!
  livestockUnitId: String!
  name: String
  nlisid: String
  parentId: String
  sex: Sex!
}

input LivestockUnitListRelationFilter {
  every: LivestockUnitWhereInput
  none: LivestockUnitWhereInput
  some: LivestockUnitWhereInput
}

type LivestockUnitMaxAggregate {
  birthdate: DateTime
  comment: String
  desexed: Boolean
  id: String
  livestockUnitId: String
  name: String
  nlisid: String
  parentId: String
  sex: Sex
}

input LivestockUnitMaxOrderByAggregateInput {
  birthdate: SortOrder
  comment: SortOrder
  desexed: SortOrder
  id: SortOrder
  livestockUnitId: SortOrder
  name: SortOrder
  nlisid: SortOrder
  parentId: SortOrder
  sex: SortOrder
}

type LivestockUnitMinAggregate {
  birthdate: DateTime
  comment: String
  desexed: Boolean
  id: String
  livestockUnitId: String
  name: String
  nlisid: String
  parentId: String
  sex: Sex
}

input LivestockUnitMinOrderByAggregateInput {
  birthdate: SortOrder
  comment: SortOrder
  desexed: SortOrder
  id: SortOrder
  livestockUnitId: SortOrder
  name: SortOrder
  nlisid: SortOrder
  parentId: SortOrder
  sex: SortOrder
}

input LivestockUnitOrderByRelationAggregateInput {
  _count: SortOrder
}

input LivestockUnitOrderByWithAggregationInput {
  _count: LivestockUnitCountOrderByAggregateInput
  _max: LivestockUnitMaxOrderByAggregateInput
  _min: LivestockUnitMinOrderByAggregateInput
  birthdate: SortOrder
  comment: SortOrder
  desexed: SortOrder
  id: SortOrder
  livestockUnitId: SortOrder
  name: SortOrder
  nlisid: SortOrder
  parentId: SortOrder
  sex: SortOrder
}

input LivestockUnitOrderByWithRelationInput {
  birthdate: SortOrder
  breed: BreedOrderByWithRelationInput
  comment: SortOrder
  dam: LivestockUnitOrderByWithRelationInput
  desexed: SortOrder
  id: SortOrder
  livestockUnitId: SortOrder
  mob: MobOrderByWithRelationInput
  name: SortOrder
  nlisid: SortOrder
  parentId: SortOrder
  sex: SortOrder
  sire: LivestockUnitOrderByWithRelationInput
  weights: WeightRecordOrderByRelationAggregateInput
}

input LivestockUnitRelationFilter {
  is: LivestockUnitWhereInput
  isNot: LivestockUnitWhereInput
}

enum LivestockUnitScalarFieldEnum {
  birthdate
  comment
  desexed
  id
  livestockUnitId
  name
  nlisid
  parentId
  sex
}

input LivestockUnitScalarWhereInput {
  AND: [LivestockUnitScalarWhereInput!]
  NOT: [LivestockUnitScalarWhereInput!]
  OR: [LivestockUnitScalarWhereInput!]
  birthdate: DateTimeFilter
  comment: StringNullableFilter
  desexed: BoolFilter
  id: StringFilter
  livestockUnitId: StringFilter
  name: StringNullableFilter
  nlisid: StringNullableFilter
  parentId: StringNullableFilter
  sex: EnumSexFilter
}

input LivestockUnitScalarWhereWithAggregatesInput {
  AND: [LivestockUnitScalarWhereWithAggregatesInput!]
  NOT: [LivestockUnitScalarWhereWithAggregatesInput!]
  OR: [LivestockUnitScalarWhereWithAggregatesInput!]
  birthdate: DateTimeWithAggregatesFilter
  comment: StringNullableWithAggregatesFilter
  desexed: BoolWithAggregatesFilter
  id: StringWithAggregatesFilter
  livestockUnitId: StringWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  nlisid: StringNullableWithAggregatesFilter
  parentId: StringNullableWithAggregatesFilter
  sex: EnumSexWithAggregatesFilter
}

input LivestockUnitUpdateInput {
  birthdate: DateTimeFieldUpdateOperationsInput
  breed: BreedUpdateOneWithoutMembersNestedInput
  comment: NullableStringFieldUpdateOperationsInput
  dam: LivestockUnitUpdateOneWithoutSireNestedInput
  desexed: BoolFieldUpdateOperationsInput
  mob: MobUpdateOneRequiredWithoutMembersNestedInput
  name: NullableStringFieldUpdateOperationsInput
  nlisid: NullableStringFieldUpdateOperationsInput
  sex: EnumSexFieldUpdateOperationsInput
  sire: LivestockUnitUpdateOneWithoutDamNestedInput
  weights: WeightRecordUpdateManyWithoutLivestockUnitNestedInput
}

input LivestockUnitUpdateManyMutationInput {
  birthdate: DateTimeFieldUpdateOperationsInput
  comment: NullableStringFieldUpdateOperationsInput
  desexed: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  nlisid: NullableStringFieldUpdateOperationsInput
  sex: EnumSexFieldUpdateOperationsInput
}

input LivestockUnitUpdateManyWithWhereWithoutMobInput {
  data: LivestockUnitUpdateManyMutationInput!
  where: LivestockUnitScalarWhereInput!
}

input LivestockUnitUpdateManyWithoutMobNestedInput {
  connect: [LivestockUnitWhereUniqueInput!]
  connectOrCreate: [LivestockUnitCreateOrConnectWithoutMobInput!]
  create: [LivestockUnitCreateWithoutMobInput!]
  createMany: LivestockUnitCreateManyMobInputEnvelope
  delete: [LivestockUnitWhereUniqueInput!]
  deleteMany: [LivestockUnitScalarWhereInput!]
  disconnect: [LivestockUnitWhereUniqueInput!]
  set: [LivestockUnitWhereUniqueInput!]
  update: [LivestockUnitUpdateWithWhereUniqueWithoutMobInput!]
  updateMany: [LivestockUnitUpdateManyWithWhereWithoutMobInput!]
  upsert: [LivestockUnitUpsertWithWhereUniqueWithoutMobInput!]
}

input LivestockUnitUpdateOneRequiredWithoutWeightsNestedInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutWeightsInput
  create: LivestockUnitCreateWithoutWeightsInput
  update: LivestockUnitUpdateWithoutWeightsInput
  upsert: LivestockUnitUpsertWithoutWeightsInput
}

input LivestockUnitUpdateOneWithoutBreedNestedInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutBreedInput
  create: LivestockUnitCreateWithoutBreedInput
  delete: Boolean
  disconnect: Boolean
  update: LivestockUnitUpdateWithoutBreedInput
  upsert: LivestockUnitUpsertWithoutBreedInput
}

input LivestockUnitUpdateOneWithoutDamNestedInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutDamInput
  create: LivestockUnitCreateWithoutDamInput
  delete: Boolean
  disconnect: Boolean
  update: LivestockUnitUpdateWithoutDamInput
  upsert: LivestockUnitUpsertWithoutDamInput
}

input LivestockUnitUpdateOneWithoutSireNestedInput {
  connect: LivestockUnitWhereUniqueInput
  connectOrCreate: LivestockUnitCreateOrConnectWithoutSireInput
  create: LivestockUnitCreateWithoutSireInput
  delete: Boolean
  disconnect: Boolean
  update: LivestockUnitUpdateWithoutSireInput
  upsert: LivestockUnitUpsertWithoutSireInput
}

input LivestockUnitUpdateWithWhereUniqueWithoutMobInput {
  data: LivestockUnitUpdateWithoutMobInput!
  where: LivestockUnitWhereUniqueInput!
}

input LivestockUnitUpdateWithoutBreedInput {
  birthdate: DateTimeFieldUpdateOperationsInput
  comment: NullableStringFieldUpdateOperationsInput
  dam: LivestockUnitUpdateOneWithoutSireNestedInput
  desexed: BoolFieldUpdateOperationsInput
  mob: MobUpdateOneRequiredWithoutMembersNestedInput
  name: NullableStringFieldUpdateOperationsInput
  nlisid: NullableStringFieldUpdateOperationsInput
  sex: EnumSexFieldUpdateOperationsInput
  sire: LivestockUnitUpdateOneWithoutDamNestedInput
  weights: WeightRecordUpdateManyWithoutLivestockUnitNestedInput
}

input LivestockUnitUpdateWithoutDamInput {
  birthdate: DateTimeFieldUpdateOperationsInput
  breed: BreedUpdateOneWithoutMembersNestedInput
  comment: NullableStringFieldUpdateOperationsInput
  desexed: BoolFieldUpdateOperationsInput
  mob: MobUpdateOneRequiredWithoutMembersNestedInput
  name: NullableStringFieldUpdateOperationsInput
  nlisid: NullableStringFieldUpdateOperationsInput
  sex: EnumSexFieldUpdateOperationsInput
  sire: LivestockUnitUpdateOneWithoutDamNestedInput
  weights: WeightRecordUpdateManyWithoutLivestockUnitNestedInput
}

input LivestockUnitUpdateWithoutMobInput {
  birthdate: DateTimeFieldUpdateOperationsInput
  breed: BreedUpdateOneWithoutMembersNestedInput
  comment: NullableStringFieldUpdateOperationsInput
  dam: LivestockUnitUpdateOneWithoutSireNestedInput
  desexed: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  nlisid: NullableStringFieldUpdateOperationsInput
  sex: EnumSexFieldUpdateOperationsInput
  sire: LivestockUnitUpdateOneWithoutDamNestedInput
  weights: WeightRecordUpdateManyWithoutLivestockUnitNestedInput
}

input LivestockUnitUpdateWithoutSireInput {
  birthdate: DateTimeFieldUpdateOperationsInput
  breed: BreedUpdateOneWithoutMembersNestedInput
  comment: NullableStringFieldUpdateOperationsInput
  dam: LivestockUnitUpdateOneWithoutSireNestedInput
  desexed: BoolFieldUpdateOperationsInput
  mob: MobUpdateOneRequiredWithoutMembersNestedInput
  name: NullableStringFieldUpdateOperationsInput
  nlisid: NullableStringFieldUpdateOperationsInput
  sex: EnumSexFieldUpdateOperationsInput
  weights: WeightRecordUpdateManyWithoutLivestockUnitNestedInput
}

input LivestockUnitUpdateWithoutWeightsInput {
  birthdate: DateTimeFieldUpdateOperationsInput
  breed: BreedUpdateOneWithoutMembersNestedInput
  comment: NullableStringFieldUpdateOperationsInput
  dam: LivestockUnitUpdateOneWithoutSireNestedInput
  desexed: BoolFieldUpdateOperationsInput
  mob: MobUpdateOneRequiredWithoutMembersNestedInput
  name: NullableStringFieldUpdateOperationsInput
  nlisid: NullableStringFieldUpdateOperationsInput
  sex: EnumSexFieldUpdateOperationsInput
  sire: LivestockUnitUpdateOneWithoutDamNestedInput
}

input LivestockUnitUpsertWithWhereUniqueWithoutMobInput {
  create: LivestockUnitCreateWithoutMobInput!
  update: LivestockUnitUpdateWithoutMobInput!
  where: LivestockUnitWhereUniqueInput!
}

input LivestockUnitUpsertWithoutBreedInput {
  create: LivestockUnitCreateWithoutBreedInput!
  update: LivestockUnitUpdateWithoutBreedInput!
}

input LivestockUnitUpsertWithoutDamInput {
  create: LivestockUnitCreateWithoutDamInput!
  update: LivestockUnitUpdateWithoutDamInput!
}

input LivestockUnitUpsertWithoutSireInput {
  create: LivestockUnitCreateWithoutSireInput!
  update: LivestockUnitUpdateWithoutSireInput!
}

input LivestockUnitUpsertWithoutWeightsInput {
  create: LivestockUnitCreateWithoutWeightsInput!
  update: LivestockUnitUpdateWithoutWeightsInput!
}

input LivestockUnitWhereInput {
  AND: [LivestockUnitWhereInput!]
  NOT: [LivestockUnitWhereInput!]
  OR: [LivestockUnitWhereInput!]
  birthdate: DateTimeFilter
  breed: BreedRelationFilter
  comment: StringNullableFilter
  dam: LivestockUnitRelationFilter
  desexed: BoolFilter
  id: StringFilter
  livestockUnitId: StringFilter
  mob: MobRelationFilter
  name: StringNullableFilter
  nlisid: StringNullableFilter
  parentId: StringNullableFilter
  sex: EnumSexFilter
  sire: LivestockUnitRelationFilter
  weights: WeightRecordListRelationFilter
}

input LivestockUnitWhereUniqueInput {
  id: String
  livestockUnitId: String
  parentId: String
}

type Mob {
  _count: MobCount
  comment: String!
  graze(cursor: GrazeWhereUniqueInput, distinct: [GrazeScalarFieldEnum!], orderBy: [GrazeOrderByWithRelationInput!], skip: Int, take: Int, where: GrazeWhereInput): [Graze!]!
  grazeIds: [String!]!
  id: String!
  members(cursor: LivestockUnitWhereUniqueInput, distinct: [LivestockUnitScalarFieldEnum!], orderBy: [LivestockUnitOrderByWithRelationInput!], skip: Int, take: Int, where: LivestockUnitWhereInput): [LivestockUnit!]!
}

type MobCount {
  graze: Int!
  members: Int!
}

type MobCountAggregate {
  _all: Int!
  comment: Int!
  grazeIds: Int!
  id: Int!
}

input MobCountOrderByAggregateInput {
  comment: SortOrder
  grazeIds: SortOrder
  id: SortOrder
}

input MobCreateInput {
  comment: String!
  graze: GrazeCreateNestedManyWithoutMobInput
  grazeIds: MobCreategrazeIdsInput
  id: String
  members: LivestockUnitCreateNestedManyWithoutMobInput
}

input MobCreateManyInput {
  comment: String!
  grazeIds: MobCreategrazeIdsInput
  id: String
}

input MobCreateNestedManyWithoutGrazeInput {
  connect: [MobWhereUniqueInput!]
  connectOrCreate: [MobCreateOrConnectWithoutGrazeInput!]
  create: [MobCreateWithoutGrazeInput!]
}

input MobCreateNestedOneWithoutMembersInput {
  connect: MobWhereUniqueInput
  connectOrCreate: MobCreateOrConnectWithoutMembersInput
  create: MobCreateWithoutMembersInput
}

input MobCreateOrConnectWithoutGrazeInput {
  create: MobCreateWithoutGrazeInput!
  where: MobWhereUniqueInput!
}

input MobCreateOrConnectWithoutMembersInput {
  create: MobCreateWithoutMembersInput!
  where: MobWhereUniqueInput!
}

input MobCreateWithoutGrazeInput {
  comment: String!
  grazeIds: MobCreategrazeIdsInput
  id: String
  members: LivestockUnitCreateNestedManyWithoutMobInput
}

input MobCreateWithoutMembersInput {
  comment: String!
  graze: GrazeCreateNestedManyWithoutMobInput
  grazeIds: MobCreategrazeIdsInput
  id: String
}

input MobCreategrazeIdsInput {
  set: [String!]!
}

type MobGroupBy {
  _count: MobCountAggregate
  _max: MobMaxAggregate
  _min: MobMinAggregate
  comment: String!
  grazeIds: [String!]
  id: String!
}

input MobListRelationFilter {
  every: MobWhereInput
  none: MobWhereInput
  some: MobWhereInput
}

type MobMaxAggregate {
  comment: String
  id: String
}

input MobMaxOrderByAggregateInput {
  comment: SortOrder
  id: SortOrder
}

type MobMinAggregate {
  comment: String
  id: String
}

input MobMinOrderByAggregateInput {
  comment: SortOrder
  id: SortOrder
}

input MobOrderByRelationAggregateInput {
  _count: SortOrder
}

input MobOrderByWithAggregationInput {
  _count: MobCountOrderByAggregateInput
  _max: MobMaxOrderByAggregateInput
  _min: MobMinOrderByAggregateInput
  comment: SortOrder
  grazeIds: SortOrder
  id: SortOrder
}

input MobOrderByWithRelationInput {
  comment: SortOrder
  graze: GrazeOrderByRelationAggregateInput
  grazeIds: SortOrder
  id: SortOrder
  members: LivestockUnitOrderByRelationAggregateInput
}

input MobRelationFilter {
  is: MobWhereInput
  isNot: MobWhereInput
}

enum MobScalarFieldEnum {
  comment
  grazeIds
  id
}

input MobScalarWhereInput {
  AND: [MobScalarWhereInput!]
  NOT: [MobScalarWhereInput!]
  OR: [MobScalarWhereInput!]
  comment: StringFilter
  grazeIds: StringNullableListFilter
  id: StringFilter
}

input MobScalarWhereWithAggregatesInput {
  AND: [MobScalarWhereWithAggregatesInput!]
  NOT: [MobScalarWhereWithAggregatesInput!]
  OR: [MobScalarWhereWithAggregatesInput!]
  comment: StringWithAggregatesFilter
  grazeIds: StringNullableListFilter
  id: StringWithAggregatesFilter
}

input MobUpdateInput {
  comment: StringFieldUpdateOperationsInput
  graze: GrazeUpdateManyWithoutMobNestedInput
  grazeIds: MobUpdategrazeIdsInput
  members: LivestockUnitUpdateManyWithoutMobNestedInput
}

input MobUpdateManyMutationInput {
  comment: StringFieldUpdateOperationsInput
  grazeIds: MobUpdategrazeIdsInput
}

input MobUpdateManyWithWhereWithoutGrazeInput {
  data: MobUpdateManyMutationInput!
  where: MobScalarWhereInput!
}

input MobUpdateManyWithoutGrazeNestedInput {
  connect: [MobWhereUniqueInput!]
  connectOrCreate: [MobCreateOrConnectWithoutGrazeInput!]
  create: [MobCreateWithoutGrazeInput!]
  delete: [MobWhereUniqueInput!]
  deleteMany: [MobScalarWhereInput!]
  disconnect: [MobWhereUniqueInput!]
  set: [MobWhereUniqueInput!]
  update: [MobUpdateWithWhereUniqueWithoutGrazeInput!]
  updateMany: [MobUpdateManyWithWhereWithoutGrazeInput!]
  upsert: [MobUpsertWithWhereUniqueWithoutGrazeInput!]
}

input MobUpdateOneRequiredWithoutMembersNestedInput {
  connect: MobWhereUniqueInput
  connectOrCreate: MobCreateOrConnectWithoutMembersInput
  create: MobCreateWithoutMembersInput
  update: MobUpdateWithoutMembersInput
  upsert: MobUpsertWithoutMembersInput
}

input MobUpdateWithWhereUniqueWithoutGrazeInput {
  data: MobUpdateWithoutGrazeInput!
  where: MobWhereUniqueInput!
}

input MobUpdateWithoutGrazeInput {
  comment: StringFieldUpdateOperationsInput
  grazeIds: MobUpdategrazeIdsInput
  members: LivestockUnitUpdateManyWithoutMobNestedInput
}

input MobUpdateWithoutMembersInput {
  comment: StringFieldUpdateOperationsInput
  graze: GrazeUpdateManyWithoutMobNestedInput
  grazeIds: MobUpdategrazeIdsInput
}

input MobUpdategrazeIdsInput {
  push: [String!]
  set: [String!]
}

input MobUpsertWithWhereUniqueWithoutGrazeInput {
  create: MobCreateWithoutGrazeInput!
  update: MobUpdateWithoutGrazeInput!
  where: MobWhereUniqueInput!
}

input MobUpsertWithoutMembersInput {
  create: MobCreateWithoutMembersInput!
  update: MobUpdateWithoutMembersInput!
}

input MobWhereInput {
  AND: [MobWhereInput!]
  NOT: [MobWhereInput!]
  OR: [MobWhereInput!]
  comment: StringFilter
  graze: GrazeListRelationFilter
  grazeIds: StringNullableListFilter
  id: StringFilter
  members: LivestockUnitListRelationFilter
}

input MobWhereUniqueInput {
  id: String
}

type Mutation {
  createManyBreed(data: [BreedCreateManyInput!]!): AffectedRowsOutput!
  createManyGeoPoint(data: [GeoPointCreateManyInput!]!): AffectedRowsOutput!
  createManyGraze(data: [GrazeCreateManyInput!]!): AffectedRowsOutput!
  createManyLivestockUnit(data: [LivestockUnitCreateManyInput!]!): AffectedRowsOutput!
  createManyMob(data: [MobCreateManyInput!]!): AffectedRowsOutput!
  createManyPaddock(data: [PaddockCreateManyInput!]!): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!): AffectedRowsOutput!
  createManyWeightRecord(data: [WeightRecordCreateManyInput!]!): AffectedRowsOutput!
  createOneBreed(data: BreedCreateInput!): Breed!
  createOneGeoPoint(data: GeoPointCreateInput!): GeoPoint!
  createOneGraze(data: GrazeCreateInput!): Graze!
  createOneLivestockUnit(data: LivestockUnitCreateInput!): LivestockUnit!
  createOneMob(data: MobCreateInput!): Mob!
  createOnePaddock(data: PaddockCreateInput!): Paddock!
  createOneUser(data: UserCreateInput!): User!
  createOneWeightRecord(data: WeightRecordCreateInput!): WeightRecord!
  deleteManyBreed(where: BreedWhereInput): AffectedRowsOutput!
  deleteManyGeoPoint(where: GeoPointWhereInput): AffectedRowsOutput!
  deleteManyGraze(where: GrazeWhereInput): AffectedRowsOutput!
  deleteManyLivestockUnit(where: LivestockUnitWhereInput): AffectedRowsOutput!
  deleteManyMob(where: MobWhereInput): AffectedRowsOutput!
  deleteManyPaddock(where: PaddockWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyWeightRecord(where: WeightRecordWhereInput): AffectedRowsOutput!
  deleteOneBreed(where: BreedWhereUniqueInput!): Breed
  deleteOneGeoPoint(where: GeoPointWhereUniqueInput!): GeoPoint
  deleteOneGraze(where: GrazeWhereUniqueInput!): Graze
  deleteOneLivestockUnit(where: LivestockUnitWhereUniqueInput!): LivestockUnit
  deleteOneMob(where: MobWhereUniqueInput!): Mob
  deleteOnePaddock(where: PaddockWhereUniqueInput!): Paddock
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneWeightRecord(where: WeightRecordWhereUniqueInput!): WeightRecord
  updateManyBreed(data: BreedUpdateManyMutationInput!, where: BreedWhereInput): AffectedRowsOutput!
  updateManyGeoPoint(data: GeoPointUpdateManyMutationInput!, where: GeoPointWhereInput): AffectedRowsOutput!
  updateManyGraze(data: GrazeUpdateManyMutationInput!, where: GrazeWhereInput): AffectedRowsOutput!
  updateManyLivestockUnit(data: LivestockUnitUpdateManyMutationInput!, where: LivestockUnitWhereInput): AffectedRowsOutput!
  updateManyMob(data: MobUpdateManyMutationInput!, where: MobWhereInput): AffectedRowsOutput!
  updateManyPaddock(data: PaddockUpdateManyMutationInput!, where: PaddockWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyWeightRecord(data: WeightRecordUpdateManyMutationInput!, where: WeightRecordWhereInput): AffectedRowsOutput!
  updateOneBreed(data: BreedUpdateInput!, where: BreedWhereUniqueInput!): Breed
  updateOneGeoPoint(data: GeoPointUpdateInput!, where: GeoPointWhereUniqueInput!): GeoPoint
  updateOneGraze(data: GrazeUpdateInput!, where: GrazeWhereUniqueInput!): Graze
  updateOneLivestockUnit(data: LivestockUnitUpdateInput!, where: LivestockUnitWhereUniqueInput!): LivestockUnit
  updateOneMob(data: MobUpdateInput!, where: MobWhereUniqueInput!): Mob
  updateOnePaddock(data: PaddockUpdateInput!, where: PaddockWhereUniqueInput!): Paddock
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneWeightRecord(data: WeightRecordUpdateInput!, where: WeightRecordWhereUniqueInput!): WeightRecord
  upsertOneBreed(create: BreedCreateInput!, update: BreedUpdateInput!, where: BreedWhereUniqueInput!): Breed!
  upsertOneGeoPoint(create: GeoPointCreateInput!, update: GeoPointUpdateInput!, where: GeoPointWhereUniqueInput!): GeoPoint!
  upsertOneGraze(create: GrazeCreateInput!, update: GrazeUpdateInput!, where: GrazeWhereUniqueInput!): Graze!
  upsertOneLivestockUnit(create: LivestockUnitCreateInput!, update: LivestockUnitUpdateInput!, where: LivestockUnitWhereUniqueInput!): LivestockUnit!
  upsertOneMob(create: MobCreateInput!, update: MobUpdateInput!, where: MobWhereUniqueInput!): Mob!
  upsertOnePaddock(create: PaddockCreateInput!, update: PaddockUpdateInput!, where: PaddockWhereUniqueInput!): Paddock!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneWeightRecord(create: WeightRecordCreateInput!, update: WeightRecordUpdateInput!, where: WeightRecordWhereUniqueInput!): WeightRecord!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  isSet: Boolean
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  isSet: Boolean
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumSexFilter {
  equals: Sex
  in: [Sex!]
  not: NestedEnumSexFilter
  notIn: [Sex!]
}

input NestedEnumSexWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumSexFilter
  _min: NestedEnumSexFilter
  equals: Sex
  in: [Sex!]
  not: NestedEnumSexWithAggregatesFilter
  notIn: [Sex!]
}

input NestedEnumStockClassFilter {
  equals: StockClass
  in: [StockClass!]
  not: NestedEnumStockClassFilter
  notIn: [StockClass!]
}

input NestedEnumStockClassWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumStockClassFilter
  _min: NestedEnumStockClassFilter
  equals: StockClass
  in: [StockClass!]
  not: NestedEnumStockClassWithAggregatesFilter
  notIn: [StockClass!]
}

input NestedEnumWeighMethodFilter {
  equals: WeighMethod
  in: [WeighMethod!]
  not: NestedEnumWeighMethodFilter
  notIn: [WeighMethod!]
}

input NestedEnumWeighMethodWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumWeighMethodFilter
  _min: NestedEnumWeighMethodFilter
  equals: WeighMethod
  in: [WeighMethod!]
  not: NestedEnumWeighMethodWithAggregatesFilter
  notIn: [WeighMethod!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  isSet: Boolean
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  isSet: Boolean
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  isSet: Boolean
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
  unset: Boolean
}

input NullableStringFieldUpdateOperationsInput {
  set: String
  unset: Boolean
}

type Paddock {
  _count: PaddockCount
  graze(cursor: GrazeWhereUniqueInput, distinct: [GrazeScalarFieldEnum!], orderBy: [GrazeOrderByWithRelationInput!], skip: Int, take: Int, where: GrazeWhereInput): [Graze!]!
  id: String!
  name: String!
  polygon(cursor: GeoPointWhereUniqueInput, distinct: [GeoPointScalarFieldEnum!], orderBy: [GeoPointOrderByWithRelationInput!], skip: Int, take: Int, where: GeoPointWhereInput): [GeoPoint!]!
}

type PaddockCount {
  graze: Int!
  polygon: Int!
}

type PaddockCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input PaddockCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input PaddockCreateInput {
  graze: GrazeCreateNestedManyWithoutPaddockInput
  id: String
  name: String!
  polygon: GeoPointCreateNestedManyWithoutPaddockInput
}

input PaddockCreateManyInput {
  id: String
  name: String!
}

input PaddockCreateNestedOneWithoutGrazeInput {
  connect: PaddockWhereUniqueInput
  connectOrCreate: PaddockCreateOrConnectWithoutGrazeInput
  create: PaddockCreateWithoutGrazeInput
}

input PaddockCreateNestedOneWithoutPolygonInput {
  connect: PaddockWhereUniqueInput
  connectOrCreate: PaddockCreateOrConnectWithoutPolygonInput
  create: PaddockCreateWithoutPolygonInput
}

input PaddockCreateOrConnectWithoutGrazeInput {
  create: PaddockCreateWithoutGrazeInput!
  where: PaddockWhereUniqueInput!
}

input PaddockCreateOrConnectWithoutPolygonInput {
  create: PaddockCreateWithoutPolygonInput!
  where: PaddockWhereUniqueInput!
}

input PaddockCreateWithoutGrazeInput {
  id: String
  name: String!
  polygon: GeoPointCreateNestedManyWithoutPaddockInput
}

input PaddockCreateWithoutPolygonInput {
  graze: GrazeCreateNestedManyWithoutPaddockInput
  id: String
  name: String!
}

type PaddockGroupBy {
  _count: PaddockCountAggregate
  _max: PaddockMaxAggregate
  _min: PaddockMinAggregate
  id: String!
  name: String!
}

type PaddockMaxAggregate {
  id: String
  name: String
}

input PaddockMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type PaddockMinAggregate {
  id: String
  name: String
}

input PaddockMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input PaddockOrderByWithAggregationInput {
  _count: PaddockCountOrderByAggregateInput
  _max: PaddockMaxOrderByAggregateInput
  _min: PaddockMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input PaddockOrderByWithRelationInput {
  graze: GrazeOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  polygon: GeoPointOrderByRelationAggregateInput
}

input PaddockRelationFilter {
  is: PaddockWhereInput
  isNot: PaddockWhereInput
}

enum PaddockScalarFieldEnum {
  id
  name
}

input PaddockScalarWhereWithAggregatesInput {
  AND: [PaddockScalarWhereWithAggregatesInput!]
  NOT: [PaddockScalarWhereWithAggregatesInput!]
  OR: [PaddockScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input PaddockUpdateInput {
  graze: GrazeUpdateManyWithoutPaddockNestedInput
  name: StringFieldUpdateOperationsInput
  polygon: GeoPointUpdateManyWithoutPaddockNestedInput
}

input PaddockUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input PaddockUpdateOneRequiredWithoutGrazeNestedInput {
  connect: PaddockWhereUniqueInput
  connectOrCreate: PaddockCreateOrConnectWithoutGrazeInput
  create: PaddockCreateWithoutGrazeInput
  update: PaddockUpdateWithoutGrazeInput
  upsert: PaddockUpsertWithoutGrazeInput
}

input PaddockUpdateOneRequiredWithoutPolygonNestedInput {
  connect: PaddockWhereUniqueInput
  connectOrCreate: PaddockCreateOrConnectWithoutPolygonInput
  create: PaddockCreateWithoutPolygonInput
  update: PaddockUpdateWithoutPolygonInput
  upsert: PaddockUpsertWithoutPolygonInput
}

input PaddockUpdateWithoutGrazeInput {
  name: StringFieldUpdateOperationsInput
  polygon: GeoPointUpdateManyWithoutPaddockNestedInput
}

input PaddockUpdateWithoutPolygonInput {
  graze: GrazeUpdateManyWithoutPaddockNestedInput
  name: StringFieldUpdateOperationsInput
}

input PaddockUpsertWithoutGrazeInput {
  create: PaddockCreateWithoutGrazeInput!
  update: PaddockUpdateWithoutGrazeInput!
}

input PaddockUpsertWithoutPolygonInput {
  create: PaddockCreateWithoutPolygonInput!
  update: PaddockUpdateWithoutPolygonInput!
}

input PaddockWhereInput {
  AND: [PaddockWhereInput!]
  NOT: [PaddockWhereInput!]
  OR: [PaddockWhereInput!]
  graze: GrazeListRelationFilter
  id: StringFilter
  name: StringFilter
  polygon: GeoPointListRelationFilter
}

input PaddockWhereUniqueInput {
  id: String
}

type Query {
  aggregateBreed(cursor: BreedWhereUniqueInput, orderBy: [BreedOrderByWithRelationInput!], skip: Int, take: Int, where: BreedWhereInput): AggregateBreed!
  aggregateGeoPoint(cursor: GeoPointWhereUniqueInput, orderBy: [GeoPointOrderByWithRelationInput!], skip: Int, take: Int, where: GeoPointWhereInput): AggregateGeoPoint!
  aggregateGraze(cursor: GrazeWhereUniqueInput, orderBy: [GrazeOrderByWithRelationInput!], skip: Int, take: Int, where: GrazeWhereInput): AggregateGraze!
  aggregateLivestockUnit(cursor: LivestockUnitWhereUniqueInput, orderBy: [LivestockUnitOrderByWithRelationInput!], skip: Int, take: Int, where: LivestockUnitWhereInput): AggregateLivestockUnit!
  aggregateMob(cursor: MobWhereUniqueInput, orderBy: [MobOrderByWithRelationInput!], skip: Int, take: Int, where: MobWhereInput): AggregateMob!
  aggregatePaddock(cursor: PaddockWhereUniqueInput, orderBy: [PaddockOrderByWithRelationInput!], skip: Int, take: Int, where: PaddockWhereInput): AggregatePaddock!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateWeightRecord(cursor: WeightRecordWhereUniqueInput, orderBy: [WeightRecordOrderByWithRelationInput!], skip: Int, take: Int, where: WeightRecordWhereInput): AggregateWeightRecord!
  breed(where: BreedWhereUniqueInput!): Breed
  breeds(cursor: BreedWhereUniqueInput, distinct: [BreedScalarFieldEnum!], orderBy: [BreedOrderByWithRelationInput!], skip: Int, take: Int, where: BreedWhereInput): [Breed!]!
  findFirstBreed(cursor: BreedWhereUniqueInput, distinct: [BreedScalarFieldEnum!], orderBy: [BreedOrderByWithRelationInput!], skip: Int, take: Int, where: BreedWhereInput): Breed
  findFirstGeoPoint(cursor: GeoPointWhereUniqueInput, distinct: [GeoPointScalarFieldEnum!], orderBy: [GeoPointOrderByWithRelationInput!], skip: Int, take: Int, where: GeoPointWhereInput): GeoPoint
  findFirstGraze(cursor: GrazeWhereUniqueInput, distinct: [GrazeScalarFieldEnum!], orderBy: [GrazeOrderByWithRelationInput!], skip: Int, take: Int, where: GrazeWhereInput): Graze
  findFirstLivestockUnit(cursor: LivestockUnitWhereUniqueInput, distinct: [LivestockUnitScalarFieldEnum!], orderBy: [LivestockUnitOrderByWithRelationInput!], skip: Int, take: Int, where: LivestockUnitWhereInput): LivestockUnit
  findFirstMob(cursor: MobWhereUniqueInput, distinct: [MobScalarFieldEnum!], orderBy: [MobOrderByWithRelationInput!], skip: Int, take: Int, where: MobWhereInput): Mob
  findFirstPaddock(cursor: PaddockWhereUniqueInput, distinct: [PaddockScalarFieldEnum!], orderBy: [PaddockOrderByWithRelationInput!], skip: Int, take: Int, where: PaddockWhereInput): Paddock
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstWeightRecord(cursor: WeightRecordWhereUniqueInput, distinct: [WeightRecordScalarFieldEnum!], orderBy: [WeightRecordOrderByWithRelationInput!], skip: Int, take: Int, where: WeightRecordWhereInput): WeightRecord
  geoPoint(where: GeoPointWhereUniqueInput!): GeoPoint
  geoPoints(cursor: GeoPointWhereUniqueInput, distinct: [GeoPointScalarFieldEnum!], orderBy: [GeoPointOrderByWithRelationInput!], skip: Int, take: Int, where: GeoPointWhereInput): [GeoPoint!]!
  graze(where: GrazeWhereUniqueInput!): Graze
  grazes(cursor: GrazeWhereUniqueInput, distinct: [GrazeScalarFieldEnum!], orderBy: [GrazeOrderByWithRelationInput!], skip: Int, take: Int, where: GrazeWhereInput): [Graze!]!
  groupByBreed(by: [BreedScalarFieldEnum!]!, having: BreedScalarWhereWithAggregatesInput, orderBy: [BreedOrderByWithAggregationInput!], skip: Int, take: Int, where: BreedWhereInput): [BreedGroupBy!]!
  groupByGeoPoint(by: [GeoPointScalarFieldEnum!]!, having: GeoPointScalarWhereWithAggregatesInput, orderBy: [GeoPointOrderByWithAggregationInput!], skip: Int, take: Int, where: GeoPointWhereInput): [GeoPointGroupBy!]!
  groupByGraze(by: [GrazeScalarFieldEnum!]!, having: GrazeScalarWhereWithAggregatesInput, orderBy: [GrazeOrderByWithAggregationInput!], skip: Int, take: Int, where: GrazeWhereInput): [GrazeGroupBy!]!
  groupByLivestockUnit(by: [LivestockUnitScalarFieldEnum!]!, having: LivestockUnitScalarWhereWithAggregatesInput, orderBy: [LivestockUnitOrderByWithAggregationInput!], skip: Int, take: Int, where: LivestockUnitWhereInput): [LivestockUnitGroupBy!]!
  groupByMob(by: [MobScalarFieldEnum!]!, having: MobScalarWhereWithAggregatesInput, orderBy: [MobOrderByWithAggregationInput!], skip: Int, take: Int, where: MobWhereInput): [MobGroupBy!]!
  groupByPaddock(by: [PaddockScalarFieldEnum!]!, having: PaddockScalarWhereWithAggregatesInput, orderBy: [PaddockOrderByWithAggregationInput!], skip: Int, take: Int, where: PaddockWhereInput): [PaddockGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByWeightRecord(by: [WeightRecordScalarFieldEnum!]!, having: WeightRecordScalarWhereWithAggregatesInput, orderBy: [WeightRecordOrderByWithAggregationInput!], skip: Int, take: Int, where: WeightRecordWhereInput): [WeightRecordGroupBy!]!
  livestockUnit(where: LivestockUnitWhereUniqueInput!): LivestockUnit
  livestockUnits(cursor: LivestockUnitWhereUniqueInput, distinct: [LivestockUnitScalarFieldEnum!], orderBy: [LivestockUnitOrderByWithRelationInput!], skip: Int, take: Int, where: LivestockUnitWhereInput): [LivestockUnit!]!
  mob(where: MobWhereUniqueInput!): Mob
  mobs(cursor: MobWhereUniqueInput, distinct: [MobScalarFieldEnum!], orderBy: [MobOrderByWithRelationInput!], skip: Int, take: Int, where: MobWhereInput): [Mob!]!
  paddock(where: PaddockWhereUniqueInput!): Paddock
  paddocks(cursor: PaddockWhereUniqueInput, distinct: [PaddockScalarFieldEnum!], orderBy: [PaddockOrderByWithRelationInput!], skip: Int, take: Int, where: PaddockWhereInput): [Paddock!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  weightRecord(where: WeightRecordWhereUniqueInput!): WeightRecord
  weightRecords(cursor: WeightRecordWhereUniqueInput, distinct: [WeightRecordScalarFieldEnum!], orderBy: [WeightRecordOrderByWithRelationInput!], skip: Int, take: Int, where: WeightRecordWhereInput): [WeightRecord!]!
}

enum QueryMode {
  default
  insensitive
}

enum Sex {
  FEMALE
  MALE
}

enum SortOrder {
  asc
  desc
}

enum StockClass {
  ALPACA
  CAMEL
  CATTLE
  CHICKEN
  DUCK
  GOAT
  SHEEP
  TURKEY
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  isSet: Boolean
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  isSet: Boolean
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  id: String!
  name: String
}

type UserCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input UserCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input UserCreateInput {
  id: String
  name: String
}

input UserCreateManyInput {
  id: String
  name: String
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  id: String!
  name: String
}

type UserMaxAggregate {
  id: String
  name: String
}

input UserMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type UserMinAggregate {
  id: String
  name: String
}

input UserMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
}

enum UserScalarFieldEnum {
  id
  name
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
}

input UserUpdateInput {
  name: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  name: NullableStringFieldUpdateOperationsInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: StringFilter
  name: StringNullableFilter
}

input UserWhereUniqueInput {
  id: String
}

enum WeighMethod {
  IMAGE_ANALYSIS
  MOB_AVERAGE
  SCALES
  VISUAL_ESTIMATE
}

type WeightRecord {
  dateMeasured: DateTime!
  id: String!
  livestockUnit: LivestockUnit!
  livestockunitId: String!
  method: WeighMethod!
  weight: Float!
}

type WeightRecordAvgAggregate {
  weight: Float
}

input WeightRecordAvgOrderByAggregateInput {
  weight: SortOrder
}

type WeightRecordCountAggregate {
  _all: Int!
  dateMeasured: Int!
  id: Int!
  livestockunitId: Int!
  method: Int!
  weight: Int!
}

input WeightRecordCountOrderByAggregateInput {
  dateMeasured: SortOrder
  id: SortOrder
  livestockunitId: SortOrder
  method: SortOrder
  weight: SortOrder
}

input WeightRecordCreateInput {
  dateMeasured: DateTime
  id: String
  livestockUnit: LivestockUnitCreateNestedOneWithoutWeightsInput!
  method: WeighMethod
  weight: Float!
}

input WeightRecordCreateManyInput {
  dateMeasured: DateTime
  id: String
  livestockunitId: String!
  method: WeighMethod
  weight: Float!
}

input WeightRecordCreateManyLivestockUnitInput {
  dateMeasured: DateTime
  id: String
  method: WeighMethod
  weight: Float!
}

input WeightRecordCreateManyLivestockUnitInputEnvelope {
  data: [WeightRecordCreateManyLivestockUnitInput!]!
}

input WeightRecordCreateNestedManyWithoutLivestockUnitInput {
  connect: [WeightRecordWhereUniqueInput!]
  connectOrCreate: [WeightRecordCreateOrConnectWithoutLivestockUnitInput!]
  create: [WeightRecordCreateWithoutLivestockUnitInput!]
  createMany: WeightRecordCreateManyLivestockUnitInputEnvelope
}

input WeightRecordCreateOrConnectWithoutLivestockUnitInput {
  create: WeightRecordCreateWithoutLivestockUnitInput!
  where: WeightRecordWhereUniqueInput!
}

input WeightRecordCreateWithoutLivestockUnitInput {
  dateMeasured: DateTime
  id: String
  method: WeighMethod
  weight: Float!
}

type WeightRecordGroupBy {
  _avg: WeightRecordAvgAggregate
  _count: WeightRecordCountAggregate
  _max: WeightRecordMaxAggregate
  _min: WeightRecordMinAggregate
  _sum: WeightRecordSumAggregate
  dateMeasured: DateTime!
  id: String!
  livestockunitId: String!
  method: WeighMethod!
  weight: Float!
}

input WeightRecordListRelationFilter {
  every: WeightRecordWhereInput
  none: WeightRecordWhereInput
  some: WeightRecordWhereInput
}

type WeightRecordMaxAggregate {
  dateMeasured: DateTime
  id: String
  livestockunitId: String
  method: WeighMethod
  weight: Float
}

input WeightRecordMaxOrderByAggregateInput {
  dateMeasured: SortOrder
  id: SortOrder
  livestockunitId: SortOrder
  method: SortOrder
  weight: SortOrder
}

type WeightRecordMinAggregate {
  dateMeasured: DateTime
  id: String
  livestockunitId: String
  method: WeighMethod
  weight: Float
}

input WeightRecordMinOrderByAggregateInput {
  dateMeasured: SortOrder
  id: SortOrder
  livestockunitId: SortOrder
  method: SortOrder
  weight: SortOrder
}

input WeightRecordOrderByRelationAggregateInput {
  _count: SortOrder
}

input WeightRecordOrderByWithAggregationInput {
  _avg: WeightRecordAvgOrderByAggregateInput
  _count: WeightRecordCountOrderByAggregateInput
  _max: WeightRecordMaxOrderByAggregateInput
  _min: WeightRecordMinOrderByAggregateInput
  _sum: WeightRecordSumOrderByAggregateInput
  dateMeasured: SortOrder
  id: SortOrder
  livestockunitId: SortOrder
  method: SortOrder
  weight: SortOrder
}

input WeightRecordOrderByWithRelationInput {
  dateMeasured: SortOrder
  id: SortOrder
  livestockUnit: LivestockUnitOrderByWithRelationInput
  livestockunitId: SortOrder
  method: SortOrder
  weight: SortOrder
}

enum WeightRecordScalarFieldEnum {
  dateMeasured
  id
  livestockunitId
  method
  weight
}

input WeightRecordScalarWhereInput {
  AND: [WeightRecordScalarWhereInput!]
  NOT: [WeightRecordScalarWhereInput!]
  OR: [WeightRecordScalarWhereInput!]
  dateMeasured: DateTimeFilter
  id: StringFilter
  livestockunitId: StringFilter
  method: EnumWeighMethodFilter
  weight: FloatFilter
}

input WeightRecordScalarWhereWithAggregatesInput {
  AND: [WeightRecordScalarWhereWithAggregatesInput!]
  NOT: [WeightRecordScalarWhereWithAggregatesInput!]
  OR: [WeightRecordScalarWhereWithAggregatesInput!]
  dateMeasured: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  livestockunitId: StringWithAggregatesFilter
  method: EnumWeighMethodWithAggregatesFilter
  weight: FloatWithAggregatesFilter
}

type WeightRecordSumAggregate {
  weight: Float
}

input WeightRecordSumOrderByAggregateInput {
  weight: SortOrder
}

input WeightRecordUpdateInput {
  dateMeasured: DateTimeFieldUpdateOperationsInput
  livestockUnit: LivestockUnitUpdateOneRequiredWithoutWeightsNestedInput
  method: EnumWeighMethodFieldUpdateOperationsInput
  weight: FloatFieldUpdateOperationsInput
}

input WeightRecordUpdateManyMutationInput {
  dateMeasured: DateTimeFieldUpdateOperationsInput
  method: EnumWeighMethodFieldUpdateOperationsInput
  weight: FloatFieldUpdateOperationsInput
}

input WeightRecordUpdateManyWithWhereWithoutLivestockUnitInput {
  data: WeightRecordUpdateManyMutationInput!
  where: WeightRecordScalarWhereInput!
}

input WeightRecordUpdateManyWithoutLivestockUnitNestedInput {
  connect: [WeightRecordWhereUniqueInput!]
  connectOrCreate: [WeightRecordCreateOrConnectWithoutLivestockUnitInput!]
  create: [WeightRecordCreateWithoutLivestockUnitInput!]
  createMany: WeightRecordCreateManyLivestockUnitInputEnvelope
  delete: [WeightRecordWhereUniqueInput!]
  deleteMany: [WeightRecordScalarWhereInput!]
  disconnect: [WeightRecordWhereUniqueInput!]
  set: [WeightRecordWhereUniqueInput!]
  update: [WeightRecordUpdateWithWhereUniqueWithoutLivestockUnitInput!]
  updateMany: [WeightRecordUpdateManyWithWhereWithoutLivestockUnitInput!]
  upsert: [WeightRecordUpsertWithWhereUniqueWithoutLivestockUnitInput!]
}

input WeightRecordUpdateWithWhereUniqueWithoutLivestockUnitInput {
  data: WeightRecordUpdateWithoutLivestockUnitInput!
  where: WeightRecordWhereUniqueInput!
}

input WeightRecordUpdateWithoutLivestockUnitInput {
  dateMeasured: DateTimeFieldUpdateOperationsInput
  method: EnumWeighMethodFieldUpdateOperationsInput
  weight: FloatFieldUpdateOperationsInput
}

input WeightRecordUpsertWithWhereUniqueWithoutLivestockUnitInput {
  create: WeightRecordCreateWithoutLivestockUnitInput!
  update: WeightRecordUpdateWithoutLivestockUnitInput!
  where: WeightRecordWhereUniqueInput!
}

input WeightRecordWhereInput {
  AND: [WeightRecordWhereInput!]
  NOT: [WeightRecordWhereInput!]
  OR: [WeightRecordWhereInput!]
  dateMeasured: DateTimeFilter
  id: StringFilter
  livestockUnit: LivestockUnitRelationFilter
  livestockunitId: StringFilter
  method: EnumWeighMethodFilter
  weight: FloatFilter
}

input WeightRecordWhereUniqueInput {
  id: String
}
